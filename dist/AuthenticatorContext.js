"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _config = require("./config");

var _VerifyError = _interopRequireDefault(require("./errors/VerifyError"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AUTHENTICATOR_CONTEXT_ERROR = _config.AppConfig.AUTHENTICATOR_CONTEXT_ERROR;

function AuthenticatorContext(oauth) {
  if (!oauth) {
    throw new _VerifyError.default(AUTHENTICATOR_CONTEXT_ERROR, 'Oauth parameter is required');
  }

  this.oauth = oauth;
  this.config = this.oauth.getConfig();

  if (this.config.flowType === 'Implicit') {
    this.token = this._fetchToken();
  }
}

AuthenticatorContext.prototype._fetchToken = function () {
  return this.oauth.fetchToken();
};

AuthenticatorContext.prototype._isAuthenticated = function (token) {
  return this.oauth.isAuthenticated(token);
};

AuthenticatorContext.prototype._handleResponse = function (options, token) {
  return this.oauth.handleResponse(options, token);
};
/**
 * The Authenticator object provides properties and methods to view
 * device information and remove methods
 * @param {object} tokenObj containing access_token, refresh_token ...
 */


AuthenticatorContext.prototype.authenticators = function (tokenObj) {
  var token = tokenObj || this.token;

  if (!token) {
    return Promise.reject(new _VerifyError.default(AUTHENTICATOR_CONTEXT_ERROR, 'token is a required parameter'));
  }

  var path = "".concat(this.config.tenantUrl, "/v1.0/authenticators");
  var options = {
    method: 'GET',
    url: path
  };
  return this._handleResponse(options, token);
};
/**
 * @function initiateAuthenticator
 * Initiates a new authenticator that the client can or enter manually using a mobile device.
 * This method returns base64 encoded data representing a QR code.
 * @param {object} dataObj containing a user friendly name for the registration.
 * @param {object} tokenObj containing access_token, refresh_token ...
 */


AuthenticatorContext.prototype.initiateAuthenticator = function (dataObj, tokenObj) {
  if (arguments.length < 2 && this.config.flowType !== 'Implicit') {
    return Promise.reject(new _VerifyError.default(AUTHENTICATOR_CONTEXT_ERROR, 'initiateAuthenticator(dataObj, token), 2 parameters are required ' + arguments.length + ' were given'));
  }

  if (!dataObj) {
    return Promise.reject(new _VerifyError.default(AUTHENTICATOR_CONTEXT_ERROR, 'dataObj cannot be null'));
  }

  var token = tokenObj || this.token;
  var path = "".concat(this.config.tenantUrl, "/v1.0/authenticators/initiation?qrcodeInResponse=true");
  var options = {
    method: 'POST',
    url: path,
    data: {
      owner: null,
      clientId: this.config.registrationProfileId,
      accountName: dataObj.accountName || 'Default Account'
    },
    accept: 'image/png'
  };
  return this._handleResponse(options, token);
};
/**
 * @function createVerification function creates a transaction and sends a push notification to the associated authenticator.
 * @param {string} authenticatorId Creates a new verification for the registered authenticator.
 * @param {object} formData  a JSON payload that specifies the verification transaction data
 * @param {object} tokenObj containing access_token, refresh_token ...
 */


AuthenticatorContext.prototype.createVerification = function (authenticatorId, formData, tokenObj) {
  if (arguments.length < 3 && this.config.flowType !== 'Implicit') {
    return Promise.reject(new _VerifyError.default(AUTHENTICATOR_CONTEXT_ERROR, 'createVerification(authenticatorId, formData, token), 3 parameters are required ' + arguments.length + ' were given'));
  }

  if (!formData) {
    return Promise.reject(new _VerifyError.default(AUTHENTICATOR_CONTEXT_ERROR, 'formData is a required parameter'));
  }

  var token = tokenObj || this.token;
  var path = "".concat(this.config.tenantUrl, "/v1.0/authenticators/").concat(authenticatorId, "/verifications");
  var data = {
    transactionData: {
      message: formData.txMessage || ' ',
      originIpAddress: formData.originIpAddress || ' ',
      originUserAgent: formData.originUserAgent || ' ',
      additionalData: formData.txAdditionalData
    },
    pushNotification: {
      title: formData.title || ' ',
      send: formData.send,
      message: formData.pushMessage || ' '
    },
    authenticationMethods: [{
      id: formData.methodId,
      methodType: 'signature'
    }],
    logic: 'OR',
    expiresIn: formData.expires || 120
  };
  var options = {
    method: 'POST',
    url: path,
    data: data
  };
  return this._handleResponse(options, token);
};
/**
 * @function viewVerifications Retrieve the list of verification transactions.
 * @param {string} authenticatorId The authenticator registration identifier.
 * @param {object} tokenObj containing access_token, refresh_token ...
 */


AuthenticatorContext.prototype.viewVerifications = function (authenticatorId, tokenObj) {
  if (arguments.length < 2 && this.config.flowType !== 'Implicit') {
    return Promise.reject(new _VerifyError.default(AUTHENTICATOR_CONTEXT_ERROR, 'viewVerifications(authenticatorId, token), 2 parameters are required ' + arguments.length + ' were given'));
  }

  var token = tokenObj || this.token;
  var path = "".concat(this.config.tenantUrl, "/v1.0/authenticators/").concat(authenticatorId, "/verifications");
  var options = {
    method: 'GET',
    url: path
  };
  return this._handleResponse(options, token);
};
/**
 * @function viewVerification Retrieve a specific verification transaction that is associated with an authenticator registration.
 * @param {string} authenticatorId The authenticator registration identifier.
 * @param {string} transactionId The verification transaction identifier.
 * @param {object} tokenObj containing access_token, refresh_token ...
 */


AuthenticatorContext.prototype.viewVerification = function (authenticatorId, transactionId, tokenObj) {
  if (arguments.length < 3 && this.config.flowType !== 'Implicit') {
    return Promise.reject(new _VerifyError.default(AUTHENTICATOR_CONTEXT_ERROR, 'viewVerification(authenticatorId, transactionId, token), 3 parameters are required ' + arguments.length + ' were given'));
  }

  var token = tokenObj || this.token;
  var path = "".concat(this.config.tenantUrl, "/v1.0/authenticators/").concat(authenticatorId, "/verifications/").concat(transactionId);
  var options = {
    method: 'GET',
    url: path
  };
  return this._handleResponse(options, token);
};
/**
 * @function enabled function to update attributes of a specific authenticator registration for
 * IBM Verify instances or custom mobile authenticators that are built from the IBM Verify SDK.
 * @param {string} authenticatorId Id of authenticated device
 * @param {boolean} enabled boolean to enable/disable enrolled method
 * @param {object} tokenObj containing access_token, refresh_token ...
 */


AuthenticatorContext.prototype.enabled = function (authenticatorId, enabled, tokenObj) {
  if (arguments.length < 3 && this.config.flowType !== 'Implicit') {
    return Promise.reject(new _VerifyError.default(AUTHENTICATOR_CONTEXT_ERROR, 'enabled(authenticatorId, enabled, token), 3 parameters are required ' + arguments.length + ' were given'));
  }

  var token = tokenObj || this.token;
  var path = "".concat(this.config.tenantUrl, "/v1.0/authenticators/").concat(authenticatorId);
  var options = {
    method: 'PATCH',
    url: path,
    data: [{
      path: '/enabled',
      value: enabled,
      op: 'replace'
    }],
    contentType: 'application/json-patch+json'
  };
  return this._handleResponse(options, token);
};
/**
 * @function deleteAuthenticator function to delete a specific authenticator registration for IBM Verify instances or
 * custom mobile authenticators that are built from the IBM Verify SDK.
 * @param {string} authenticatorId Id of authenticated device to be deleted.
 * @param {object} tokenObj containing access_token, refresh_token ...
 */


AuthenticatorContext.prototype.deleteAuthenticator = function (authenticatorId, tokenObj) {
  if (arguments.length < 2 && this.config.flowType !== 'Implicit') {
    return Promise.reject(new _VerifyError.default(AUTHENTICATOR_CONTEXT_ERROR, 'deleteAuthenticator(authenticatorId, token), 2 parameters are required ' + arguments.length + ' were given'));
  }

  var token = tokenObj || this.token;
  var path = "".concat(this.config.tenantUrl, "/v1.0/authenticators/").concat(authenticatorId);
  var options = {
    method: 'DELETE',
    url: path,
    data: false
  };
  return this._handleResponse(options, token);
};
/**
 * @function methodEnabled Gets or sets the current status of the method.
 * @param {string} id The signature enrollment identifier
 * @param {boolean} enabled Enable / Disable enrolled signature method.
 * @param {object} tokenObj containing access_token, refresh_token ...
 */


AuthenticatorContext.prototype.methodEnabled = function (id, enabled, tokenObj) {
  if (arguments.length < 3 && this.config.flowType !== 'Implicit') {
    return Promise.reject(new _VerifyError.default(AUTHENTICATOR_CONTEXT_ERROR, 'methodEnabled(id, enabled, token), 3 parameters are required ' + arguments.length + ' were given'));
  }

  var token = tokenObj || this.token;
  var path = "".concat(this.config.tenantUrl, "/v1.0/authnmethods/signatures/").concat(id);
  var options = {
    method: 'PATCH',
    url: path,
    data: [{
      path: '/enabled',
      value: enabled,
      op: 'replace'
    }],
    contentType: 'application/json-patch+json'
  };
  return this._handleResponse(options, token);
};
/**
 * @function methods Gets an array of method objects containing all the enrolled methods for a given authenticator.
 * @param {string} authenticatorId unique ID of registered authenticator
 * @param {object} tokenObj containing access_token, refresh_token ...
 */


AuthenticatorContext.prototype.methods = function (authenticatorId, tokenObj) {
  if (arguments.length < 2 && this.config.flowType !== 'Implicit') {
    return Promise.reject(new _VerifyError.default(AUTHENTICATOR_CONTEXT_ERROR, 'methods(authenticatorId, token), 2 parameters are required ' + arguments.length + ' were given'));
  }

  var token = tokenObj || this.token;
  var encodedValue = encodeURIComponent("attributes/authenticatorId=\"".concat(authenticatorId, "\""));
  var path = "".concat(this.config.tenantUrl, "/v1.0/authnmethods/signatures?search=").concat(encodedValue);
  var options = {
    method: 'GET',
    url: path
  };
  return this._handleResponse(options, token);
};

var _default = AuthenticatorContext;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2xpYi9BdXRoZW50aWNhdG9yQ29udGV4dC5qcyJdLCJuYW1lcyI6WyJBVVRIRU5USUNBVE9SX0NPTlRFWFRfRVJST1IiLCJBcHBDb25maWciLCJBdXRoZW50aWNhdG9yQ29udGV4dCIsIm9hdXRoIiwiVmVyaWZ5RXJyb3IiLCJjb25maWciLCJnZXRDb25maWciLCJmbG93VHlwZSIsInRva2VuIiwiX2ZldGNoVG9rZW4iLCJwcm90b3R5cGUiLCJmZXRjaFRva2VuIiwiX2lzQXV0aGVudGljYXRlZCIsImlzQXV0aGVudGljYXRlZCIsIl9oYW5kbGVSZXNwb25zZSIsIm9wdGlvbnMiLCJoYW5kbGVSZXNwb25zZSIsImF1dGhlbnRpY2F0b3JzIiwidG9rZW5PYmoiLCJQcm9taXNlIiwicmVqZWN0IiwicGF0aCIsInRlbmFudFVybCIsIm1ldGhvZCIsInVybCIsImluaXRpYXRlQXV0aGVudGljYXRvciIsImRhdGFPYmoiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJkYXRhIiwib3duZXIiLCJjbGllbnRJZCIsInJlZ2lzdHJhdGlvblByb2ZpbGVJZCIsImFjY291bnROYW1lIiwiYWNjZXB0IiwiY3JlYXRlVmVyaWZpY2F0aW9uIiwiYXV0aGVudGljYXRvcklkIiwiZm9ybURhdGEiLCJ0cmFuc2FjdGlvbkRhdGEiLCJtZXNzYWdlIiwidHhNZXNzYWdlIiwib3JpZ2luSXBBZGRyZXNzIiwib3JpZ2luVXNlckFnZW50IiwiYWRkaXRpb25hbERhdGEiLCJ0eEFkZGl0aW9uYWxEYXRhIiwicHVzaE5vdGlmaWNhdGlvbiIsInRpdGxlIiwic2VuZCIsInB1c2hNZXNzYWdlIiwiYXV0aGVudGljYXRpb25NZXRob2RzIiwiaWQiLCJtZXRob2RJZCIsIm1ldGhvZFR5cGUiLCJsb2dpYyIsImV4cGlyZXNJbiIsImV4cGlyZXMiLCJ2aWV3VmVyaWZpY2F0aW9ucyIsInZpZXdWZXJpZmljYXRpb24iLCJ0cmFuc2FjdGlvbklkIiwiZW5hYmxlZCIsInZhbHVlIiwib3AiLCJjb250ZW50VHlwZSIsImRlbGV0ZUF1dGhlbnRpY2F0b3IiLCJtZXRob2RFbmFibGVkIiwibWV0aG9kcyIsImVuY29kZWRWYWx1ZSIsImVuY29kZVVSSUNvbXBvbmVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOzs7O0lBRU9BLDJCLEdBQStCQyxpQixDQUEvQkQsMkI7O0FBRVAsU0FBU0Usb0JBQVQsQ0FBOEJDLEtBQTlCLEVBQXFDO0FBQ25DLE1BQUksQ0FBQ0EsS0FBTCxFQUFZO0FBQ1IsVUFBTSxJQUFJQyxvQkFBSixDQUFnQkosMkJBQWhCLEVBQTZDLDZCQUE3QyxDQUFOO0FBQ0g7O0FBQ0QsT0FBS0csS0FBTCxHQUFhQSxLQUFiO0FBQ0EsT0FBS0UsTUFBTCxHQUFjLEtBQUtGLEtBQUwsQ0FBV0csU0FBWCxFQUFkOztBQUNBLE1BQUksS0FBS0QsTUFBTCxDQUFZRSxRQUFaLEtBQXlCLFVBQTdCLEVBQXdDO0FBQ3RDLFNBQUtDLEtBQUwsR0FBYSxLQUFLQyxXQUFMLEVBQWI7QUFDRDtBQUNGOztBQUdEUCxvQkFBb0IsQ0FBQ1EsU0FBckIsQ0FBK0JELFdBQS9CLEdBQTZDLFlBQVU7QUFDckQsU0FBTyxLQUFLTixLQUFMLENBQVdRLFVBQVgsRUFBUDtBQUNELENBRkQ7O0FBR0FULG9CQUFvQixDQUFDUSxTQUFyQixDQUErQkUsZ0JBQS9CLEdBQWtELFVBQVNKLEtBQVQsRUFBZTtBQUMvRCxTQUFPLEtBQUtMLEtBQUwsQ0FBV1UsZUFBWCxDQUEyQkwsS0FBM0IsQ0FBUDtBQUNELENBRkQ7O0FBR0FOLG9CQUFvQixDQUFDUSxTQUFyQixDQUErQkksZUFBL0IsR0FBaUQsVUFBU0MsT0FBVCxFQUFrQlAsS0FBbEIsRUFBd0I7QUFDdkUsU0FBTyxLQUFLTCxLQUFMLENBQVdhLGNBQVgsQ0FBMEJELE9BQTFCLEVBQW1DUCxLQUFuQyxDQUFQO0FBQ0QsQ0FGRDtBQUlBOzs7Ozs7O0FBS0FOLG9CQUFvQixDQUFDUSxTQUFyQixDQUErQk8sY0FBL0IsR0FBZ0QsVUFBU0MsUUFBVCxFQUFtQjtBQUNq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JztcbmltcG9ydCBWZXJpZnlFcnJvciBmcm9tICcuL2Vycm9ycy9WZXJpZnlFcnJvcic7XG5cbmNvbnN0IHtBVVRIRU5USUNBVE9SX0NPTlRFWFRfRVJST1J9ID0gQXBwQ29uZmlnO1xuXG5mdW5jdGlvbiBBdXRoZW50aWNhdG9yQ29udGV4dChvYXV0aCkge1xuICBpZiAoIW9hdXRoKSB7XG4gICAgICB0aHJvdyBuZXcgVmVyaWZ5RXJyb3IoQVVUSEVOVElDQVRPUl9DT05URVhUX0VSUk9SLCAnT2F1dGggcGFyYW1ldGVyIGlzIHJlcXVpcmVkJyk7XG4gIH1cbiAgdGhpcy5vYXV0aCA9IG9hdXRoO1xuICB0aGlzLmNvbmZpZyA9IHRoaXMub2F1dGguZ2V0Q29uZmlnKCk7XG4gIGlmICh0aGlzLmNvbmZpZy5mbG93VHlwZSA9PT0gJ0ltcGxpY2l0Jyl7XG4gICAgdGhpcy50b2tlbiA9IHRoaXMuX2ZldGNoVG9rZW4oKTtcbiAgfVxufVxuXG5cbkF1dGhlbnRpY2F0b3JDb250ZXh0LnByb3RvdHlwZS5fZmV0Y2hUb2tlbiA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzLm9hdXRoLmZldGNoVG9rZW4oKTtcbn07XG5BdXRoZW50aWNhdG9yQ29udGV4dC5wcm90b3R5cGUuX2lzQXV0aGVudGljYXRlZCA9IGZ1bmN0aW9uKHRva2VuKXtcbiAgcmV0dXJuIHRoaXMub2F1dGguaXNBdXRoZW50aWNhdGVkKHRva2VuKTtcbn07XG5BdXRoZW50aWNhdG9yQ29udGV4dC5wcm90b3R5cGUuX2hhbmRsZVJlc3BvbnNlID0gZnVuY3Rpb24ob3B0aW9ucywgdG9rZW4pe1xuICByZXR1cm4gdGhpcy5vYXV0aC5oYW5kbGVSZXNwb25zZShvcHRpb25zLCB0b2tlbik7XG59O1xuXG4vKipcbiAqIFRoZSBBdXRoZW50aWNhdG9yIG9iamVjdCBwcm92aWRlcyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHRvIHZpZXdcbiAqIGRldmljZSBpbmZvcm1hdGlvbiBhbmQgcmVtb3ZlIG1ldGhvZHNcbiAqIEBwYXJhbSB7b2JqZWN0fSB0b2tlbk9iaiBjb250YWluaW5nIGFjY2Vzc190b2tlbiwgcmVmcmVzaF90b2tlbiAuLi5cbiAqL1xuQXV0aGVudGljYXRvckNvbnRleHQucHJvdG90eXBlLmF1dGhlbnRpY2F0b3JzID0gZnVuY3Rpb24odG9rZW5PYmopIHtcbiAgbGV0IHRva2VuID0gdG9rZW5PYmogfHwgdGhpcy50b2tlbjtcbiAgaWYgKCF0b2tlbikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBWZXJpZnlFcnJvcihBVVRIRU5USUNBVE9SX0NPTlRFWFRfRVJST1IsICd0b2tlbiBpcyBhIHJlcXVpcmVkIHBhcmFtZXRlcicpKTtcbiAgfVxuICBsZXQgcGF0aCA9IGAke3RoaXMuY29uZmlnLnRlbmFudFVybH0vdjEuMC9hdXRoZW50aWNhdG9yc2A7XG4gIGxldCBvcHRpb25zID0ge1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdXJsOiBwYXRoXG4gIH07XG5cbiAgcmV0dXJuIHRoaXMuX2hhbmRsZVJlc3BvbnNlKG9wdGlvbnMsIHRva2VuKTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIGluaXRpYXRlQXV0aGVudGljYXRvclxuICogSW5pdGlhdGVzIGEgbmV3IGF1dGhlbnRpY2F0b3IgdGhhdCB0aGUgY2xpZW50IGNhbiBvciBlbnRlciBtYW51YWxseSB1c2luZyBhIG1vYmlsZSBkZXZpY2UuXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGJhc2U2NCBlbmNvZGVkIGRhdGEgcmVwcmVzZW50aW5nIGEgUVIgY29kZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhT2JqIGNvbnRhaW5pbmcgYSB1c2VyIGZyaWVuZGx5IG5hbWUgZm9yIHRoZSByZWdpc3RyYXRpb24uXG4gKiBAcGFyYW0ge29iamVjdH0gdG9rZW5PYmogY29udGFpbmluZyBhY2Nlc3NfdG9rZW4sIHJlZnJlc2hfdG9rZW4gLi4uXG4gKi9cbkF1dGhlbnRpY2F0b3JDb250ZXh0LnByb3RvdHlwZS5pbml0aWF0ZUF1dGhlbnRpY2F0b3IgPSBmdW5jdGlvbihkYXRhT2JqLCB0b2tlbk9iaikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIgJiYgdGhpcy5jb25maWcuZmxvd1R5cGUgIT09ICdJbXBsaWNpdCcgKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFZlcmlmeUVycm9yKEFVVEhFTlRJQ0FUT1JfQ09OVEVYVF9FUlJPUiwgJ2luaXRpYXRlQXV0aGVudGljYXRvcihkYXRhT2JqLCB0b2tlbiksIDIgcGFyYW1ldGVycyBhcmUgcmVxdWlyZWQgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHdlcmUgZ2l2ZW4nKSk7XG4gIH1cblxuICBpZiAoIWRhdGFPYmopIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVmVyaWZ5RXJyb3IoQVVUSEVOVElDQVRPUl9DT05URVhUX0VSUk9SLCAnZGF0YU9iaiBjYW5ub3QgYmUgbnVsbCcpKTtcbiAgfVxuICBsZXQgdG9rZW4gPSB0b2tlbk9iaiB8fCB0aGlzLnRva2VuO1xuICBsZXQgcGF0aCA9IGAke3RoaXMuY29uZmlnLnRlbmFudFVybH0vdjEuMC9hdXRoZW50aWNhdG9ycy9pbml0aWF0aW9uP3FyY29kZUluUmVzcG9uc2U9dHJ1ZWA7XG4gIGxldCBvcHRpb25zID0ge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogcGF0aCxcbiAgICBkYXRhOiB7XG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICBjbGllbnRJZDogdGhpcy5jb25maWcucmVnaXN0cmF0aW9uUHJvZmlsZUlkLFxuICAgICAgICBhY2NvdW50TmFtZTogZGF0YU9iai5hY2NvdW50TmFtZSB8fCAnRGVmYXVsdCBBY2NvdW50J1xuICAgIH0sXG4gICAgYWNjZXB0OiAnaW1hZ2UvcG5nJ1xuICB9O1xuICByZXR1cm4gdGhpcy5faGFuZGxlUmVzcG9uc2Uob3B0aW9ucywgdG9rZW4pO1xufTtcblxuXG4vKipcbiAqIEBmdW5jdGlvbiBjcmVhdGVWZXJpZmljYXRpb24gZnVuY3Rpb24gY3JlYXRlcyBhIHRyYW5zYWN0aW9uIGFuZCBzZW5kcyBhIHB1c2ggbm90aWZpY2F0aW9uIHRvIHRoZSBhc3NvY2lhdGVkIGF1dGhlbnRpY2F0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gYXV0aGVudGljYXRvcklkIENyZWF0ZXMgYSBuZXcgdmVyaWZpY2F0aW9uIGZvciB0aGUgcmVnaXN0ZXJlZCBhdXRoZW50aWNhdG9yLlxuICogQHBhcmFtIHtvYmplY3R9IGZvcm1EYXRhICBhIEpTT04gcGF5bG9hZCB0aGF0IHNwZWNpZmllcyB0aGUgdmVyaWZpY2F0aW9uIHRyYW5zYWN0aW9uIGRhdGFcbiAqIEBwYXJhbSB7b2JqZWN0fSB0b2tlbk9iaiBjb250YWluaW5nIGFjY2Vzc190b2tlbiwgcmVmcmVzaF90b2tlbiAuLi5cbiAqL1xuQXV0aGVudGljYXRvckNvbnRleHQucHJvdG90eXBlLmNyZWF0ZVZlcmlmaWNhdGlvbiA9IGZ1bmN0aW9uKGF1dGhlbnRpY2F0b3JJZCwgZm9ybURhdGEsIHRva2VuT2JqKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMyAmJiB0aGlzLmNvbmZpZy5mbG93VHlwZSAhPT0gJ0ltcGxpY2l0Jykge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVmVyaWZ5RXJyb3IoQVVUSEVOVElDQVRPUl9DT05URVhUX0VSUk9SLCAnY3JlYXRlVmVyaWZpY2F0aW9uKGF1dGhlbnRpY2F0b3JJZCwgZm9ybURhdGEsIHRva2VuKSwgMyBwYXJhbWV0ZXJzIGFyZSByZXF1aXJlZCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgd2VyZSBnaXZlbicpKTtcbiAgfVxuICBcbiAgaWYgKCFmb3JtRGF0YSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVmVyaWZ5RXJyb3IoQVVUSEVOVElDQVRPUl9DT05URVhUX0VSUk9SLCAnZm9ybURhdGEgaXMgYSByZXF1aXJlZCBwYXJhbWV0ZXInKSk7XG4gIH1cbiAgXG4gIGxldCB0b2tlbiA9IHRva2VuT2JqIHx8IHRoaXMudG9rZW47XG4gIGxldCBwYXRoID0gYCR7dGhpcy5jb25maWcudGVuYW50VXJsfS92MS4wL2F1dGhlbnRpY2F0b3JzLyR7YXV0aGVudGljYXRvcklkfS92ZXJpZmljYXRpb25zYDtcblxuICBsZXQgZGF0YSA9IHtcbiAgICB0cmFuc2FjdGlvbkRhdGE6IHtcbiAgICAgIG1lc3NhZ2U6IGZvcm1EYXRhLnR4TWVzc2FnZSB8fCAnICcsXG4gICAgICBvcmlnaW5JcEFkZHJlc3M6IGZvcm1EYXRhLm9yaWdpbklwQWRkcmVzcyB8fCAnICcsXG4gICAgICBvcmlnaW5Vc2VyQWdlbnQ6IGZvcm1EYXRhLm9yaWdpblVzZXJBZ2VudCB8fCAnICcsXG4gICAgICBhZGRpdGlvbmFsRGF0YTogZm9ybURhdGEudHhBZGRpdGlvbmFsRGF0YVxuICAgIH0sXG4gICAgcHVzaE5vdGlmaWNhdGlvbjoge1xuICAgICAgdGl0bGU6IGZvcm1EYXRhLnRpdGxlIHx8ICcgJyxcbiAgICAgIHNlbmQ6IGZvcm1EYXRhLnNlbmQsXG4gICAgICBtZXNzYWdlOiBmb3JtRGF0YS5wdXNoTWVzc2FnZSB8fCAnICdcbiAgICB9LFxuICAgIGF1dGhlbnRpY2F0aW9uTWV0aG9kczogW3tcbiAgICAgIGlkOiBmb3JtRGF0YS5tZXRob2RJZCxcbiAgICAgIG1ldGhvZFR5cGU6ICdzaWduYXR1cmUnXG4gICAgfV0sXG4gICAgbG9naWM6ICdPUicsXG4gICAgZXhwaXJlc0luOiBmb3JtRGF0YS5leHBpcmVzIHx8IDEyMFxuICB9O1xuXG4gIGxldCBvcHRpb25zID0ge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIHVybDogcGF0aCxcbiAgICBkYXRhOiBkYXRhXG4gIH07XG5cbiAgcmV0dXJuIHRoaXMuX2hhbmRsZVJlc3BvbnNlKG9wdGlvbnMsIHRva2VuKTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIHZpZXdWZXJpZmljYXRpb25zIFJldHJpZXZlIHRoZSBsaXN0IG9mIHZlcmlmaWNhdGlvbiB0cmFuc2FjdGlvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gYXV0aGVudGljYXRvcklkIFRoZSBhdXRoZW50aWNhdG9yIHJlZ2lzdHJhdGlvbiBpZGVudGlmaWVyLlxuICogQHBhcmFtIHtvYmplY3R9IHRva2VuT2JqIGNvbnRhaW5pbmcgYWNjZXNzX3Rva2VuLCByZWZyZXNoX3Rva2VuIC4uLlxuICovXG5BdXRoZW50aWNhdG9yQ29udGV4dC5wcm90b3R5cGUudmlld1ZlcmlmaWNhdGlvbnMgPSBmdW5jdGlvbihhdXRoZW50aWNhdG9ySWQsIHRva2VuT2JqKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMiAmJiB0aGlzLmNvbmZpZy5mbG93VHlwZSAhPT0gJ0ltcGxpY2l0JyApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFZlcmlmeUVycm9yKEFVVEhFTlRJQ0FUT1JfQ09OVEVYVF9FUlJPUiwgJ3ZpZXdWZXJpZmljYXRpb25zKGF1dGhlbnRpY2F0b3JJZCwgdG9rZW4pLCAyIHBhcmFtZXRlcnMgYXJlIHJlcXVpcmVkICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyB3ZXJlIGdpdmVuJykpO1xuICB9XG4gIFxuICBsZXQgdG9rZW4gPSB0b2tlbk9iaiB8fCB0aGlzLnRva2VuO1xuICBsZXQgcGF0aCA9IGAke3RoaXMuY29uZmlnLnRlbmFudFVybH0vdjEuMC9hdXRoZW50aWNhdG9ycy8ke2F1dGhlbnRpY2F0b3JJZH0vdmVyaWZpY2F0aW9uc2A7XG4gIGxldCBvcHRpb25zID0ge1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdXJsOiBwYXRoXG4gIH07XG4gIHJldHVybiB0aGlzLl9oYW5kbGVSZXNwb25zZShvcHRpb25zLCB0b2tlbik7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiB2aWV3VmVyaWZpY2F0aW9uIFJldHJpZXZlIGEgc3BlY2lmaWMgdmVyaWZpY2F0aW9uIHRyYW5zYWN0aW9uIHRoYXQgaXMgYXNzb2NpYXRlZCB3aXRoIGFuIGF1dGhlbnRpY2F0b3IgcmVnaXN0cmF0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGF1dGhlbnRpY2F0b3JJZCBUaGUgYXV0aGVudGljYXRvciByZWdpc3RyYXRpb24gaWRlbnRpZmllci5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2FjdGlvbklkIFRoZSB2ZXJpZmljYXRpb24gdHJhbnNhY3Rpb24gaWRlbnRpZmllci5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0b2tlbk9iaiBjb250YWluaW5nIGFjY2Vzc190b2tlbiwgcmVmcmVzaF90b2tlbiAuLi5cbiAqL1xuQXV0aGVudGljYXRvckNvbnRleHQucHJvdG90eXBlLnZpZXdWZXJpZmljYXRpb24gPSBmdW5jdGlvbihhdXRoZW50aWNhdG9ySWQsIHRyYW5zYWN0aW9uSWQsIHRva2VuT2JqKXtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMyAmJiB0aGlzLmNvbmZpZy5mbG93VHlwZSAhPT0gJ0ltcGxpY2l0JyApIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBWZXJpZnlFcnJvcihBVVRIRU5USUNBVE9SX0NPTlRFWFRfRVJST1IsICd2aWV3VmVyaWZpY2F0aW9uKGF1dGhlbnRpY2F0b3JJZCwgdHJhbnNhY3Rpb25JZCwgdG9rZW4pLCAzIHBhcmFtZXRlcnMgYXJlIHJlcXVpcmVkICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyB3ZXJlIGdpdmVuJykpO1xuICAgICAgfVxuICAgICAgXG4gIGxldCB0b2tlbiA9IHRva2VuT2JqIHx8IHRoaXMudG9rZW47XG4gIGxldCBwYXRoID0gYCR7dGhpcy5jb25maWcudGVuYW50VXJsfS92MS4wL2F1dGhlbnRpY2F0b3JzLyR7YXV0aGVudGljYXRvcklkfS92ZXJpZmljYXRpb25zLyR7dHJhbnNhY3Rpb25JZH1gO1xuICBsZXQgb3B0aW9ucyA9IHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIHVybDogcGF0aFxuICB9O1xuICByZXR1cm4gdGhpcy5faGFuZGxlUmVzcG9uc2Uob3B0aW9ucywgdG9rZW4pO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gZW5hYmxlZCBmdW5jdGlvbiB0byB1cGRhdGUgYXR0cmlidXRlcyBvZiBhIHNwZWNpZmljIGF1dGhlbnRpY2F0b3IgcmVnaXN0cmF0aW9uIGZvclxuICogSUJNIFZlcmlmeSBpbnN0YW5jZXMgb3IgY3VzdG9tIG1vYmlsZSBhdXRoZW50aWNhdG9ycyB0aGF0IGFyZSBidWlsdCBmcm9tIHRoZSBJQk0gVmVyaWZ5IFNESy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhdXRoZW50aWNhdG9ySWQgSWQgb2YgYXV0aGVudGljYXRlZCBkZXZpY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZCBib29sZWFuIHRvIGVuYWJsZS9kaXNhYmxlIGVucm9sbGVkIG1ldGhvZFxuICogQHBhcmFtIHtvYmplY3R9IHRva2VuT2JqIGNvbnRhaW5pbmcgYWNjZXNzX3Rva2VuLCByZWZyZXNoX3Rva2VuIC4uLlxuICovXG5BdXRoZW50aWNhdG9yQ29udGV4dC5wcm90b3R5cGUuZW5hYmxlZCA9IGZ1bmN0aW9uKGF1dGhlbnRpY2F0b3JJZCwgZW5hYmxlZCwgdG9rZW5PYmopIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzICAmJiB0aGlzLmNvbmZpZy5mbG93VHlwZSAhPT0gJ0ltcGxpY2l0Jykge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVmVyaWZ5RXJyb3IoQVVUSEVOVElDQVRPUl9DT05URVhUX0VSUk9SLCAnZW5hYmxlZChhdXRoZW50aWNhdG9ySWQsIGVuYWJsZWQsIHRva2VuKSwgMyBwYXJhbWV0ZXJzIGFyZSByZXF1aXJlZCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgd2VyZSBnaXZlbicpKTtcbiAgfVxuICBcbiAgbGV0IHRva2VuID0gdG9rZW5PYmogfHwgdGhpcy50b2tlbjtcbiAgbGV0IHBhdGggPSBgJHt0aGlzLmNvbmZpZy50ZW5hbnRVcmx9L3YxLjAvYXV0aGVudGljYXRvcnMvJHthdXRoZW50aWNhdG9ySWR9YDtcbiAgbGV0IG9wdGlvbnMgPSB7XG4gICAgbWV0aG9kOiAnUEFUQ0gnLFxuICAgIHVybDogcGF0aCxcbiAgICBkYXRhOiBbe1xuICAgICAgcGF0aDogJy9lbmFibGVkJyxcbiAgICAgIHZhbHVlOiBlbmFibGVkLFxuICAgICAgb3A6ICdyZXBsYWNlJ1xuICAgIH1dLFxuICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbi1wYXRjaCtqc29uJ1xuICB9O1xuXG4gIHJldHVybiB0aGlzLl9oYW5kbGVSZXNwb25zZShvcHRpb25zLCB0b2tlbik7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBkZWxldGVBdXRoZW50aWNhdG9yIGZ1bmN0aW9uIHRvIGRlbGV0ZSBhIHNwZWNpZmljIGF1dGhlbnRpY2F0b3IgcmVnaXN0cmF0aW9uIGZvciBJQk0gVmVyaWZ5IGluc3RhbmNlcyBvclxuICogY3VzdG9tIG1vYmlsZSBhdXRoZW50aWNhdG9ycyB0aGF0IGFyZSBidWlsdCBmcm9tIHRoZSBJQk0gVmVyaWZ5IFNESy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhdXRoZW50aWNhdG9ySWQgSWQgb2YgYXV0aGVudGljYXRlZCBkZXZpY2UgdG8gYmUgZGVsZXRlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0b2tlbk9iaiBjb250YWluaW5nIGFjY2Vzc190b2tlbiwgcmVmcmVzaF90b2tlbiAuLi5cbiAqL1xuQXV0aGVudGljYXRvckNvbnRleHQucHJvdG90eXBlLmRlbGV0ZUF1dGhlbnRpY2F0b3IgPSBmdW5jdGlvbihhdXRoZW50aWNhdG9ySWQsIHRva2VuT2JqKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMiAgJiYgdGhpcy5jb25maWcuZmxvd1R5cGUgIT09ICdJbXBsaWNpdCcpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFZlcmlmeUVycm9yKEFVVEhFTlRJQ0FUT1JfQ09OVEVYVF9FUlJPUiwgJ2RlbGV0ZUF1dGhlbnRpY2F0b3IoYXV0aGVudGljYXRvcklkLCB0b2tlbiksIDIgcGFyYW1ldGVycyBhcmUgcmVxdWlyZWQgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHdlcmUgZ2l2ZW4nKSk7XG4gIH1cbiAgXG4gIGxldCB0b2tlbiA9IHRva2VuT2JqIHx8IHRoaXMudG9rZW47XG4gIGxldCBwYXRoID0gYCR7dGhpcy5jb25maWcudGVuYW50VXJsfS92MS4wL2F1dGhlbnRpY2F0b3JzLyR7YXV0aGVudGljYXRvcklkfWA7XG4gIGxldCBvcHRpb25zID0ge1xuICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgdXJsOiBwYXRoLFxuICAgIGRhdGE6IGZhbHNlXG4gIH07XG4gIHJldHVybiB0aGlzLl9oYW5kbGVSZXNwb25zZShvcHRpb25zLCB0b2tlbik7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBtZXRob2RFbmFibGVkIEdldHMgb3Igc2V0cyB0aGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIG1ldGhvZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgc2lnbmF0dXJlIGVucm9sbG1lbnQgaWRlbnRpZmllclxuICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkIEVuYWJsZSAvIERpc2FibGUgZW5yb2xsZWQgc2lnbmF0dXJlIG1ldGhvZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0b2tlbk9iaiBjb250YWluaW5nIGFjY2Vzc190b2tlbiwgcmVmcmVzaF90b2tlbiAuLi5cbiAqL1xuQXV0aGVudGljYXRvckNvbnRleHQucHJvdG90eXBlLm1ldGhvZEVuYWJsZWQgPSBmdW5jdGlvbihpZCwgZW5hYmxlZCwgdG9rZW5PYmopIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzICAmJiB0aGlzLmNvbmZpZy5mbG93VHlwZSAhPT0gJ0ltcGxpY2l0Jykge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVmVyaWZ5RXJyb3IoQVVUSEVOVElDQVRPUl9DT05URVhUX0VSUk9SLCAnbWV0aG9kRW5hYmxlZChpZCwgZW5hYmxlZCwgdG9rZW4pLCAzIHBhcmFtZXRlcnMgYXJlIHJlcXVpcmVkICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyB3ZXJlIGdpdmVuJykpO1xuICB9XG4gIFxuICBsZXQgdG9rZW4gPSB0b2tlbk9iaiB8fCB0aGlzLnRva2VuO1xuICBsZXQgcGF0aCA9IGAke3RoaXMuY29uZmlnLnRlbmFudFVybH0vdjEuMC9hdXRobm1ldGhvZHMvc2lnbmF0dXJlcy8ke2lkfWA7XG4gIGxldCBvcHRpb25zID0ge1xuICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICB1cmw6IHBhdGgsXG4gICAgZGF0YTogW3tcbiAgICAgIHBhdGg6ICcvZW5hYmxlZCcsXG4gICAgICB2YWx1ZTogZW5hYmxlZCxcbiAgICAgIG9wOiAncmVwbGFjZSdcbiAgICB9XSxcbiAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24tcGF0Y2granNvbidcbiAgfTtcblxuICByZXR1cm4gdGhpcy5faGFuZGxlUmVzcG9uc2Uob3B0aW9ucywgdG9rZW4pO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gbWV0aG9kcyBHZXRzIGFuIGFycmF5IG9mIG1ldGhvZCBvYmplY3RzIGNvbnRhaW5pbmcgYWxsIHRoZSBlbnJvbGxlZCBtZXRob2RzIGZvciBhIGdpdmVuIGF1dGhlbnRpY2F0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gYXV0aGVudGljYXRvcklkIHVuaXF1ZSBJRCBvZiByZWdpc3RlcmVkIGF1dGhlbnRpY2F0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSB0b2tlbk9iaiBjb250YWluaW5nIGFjY2Vzc190b2tlbiwgcmVmcmVzaF90b2tlbiAuLi5cbiAqL1xuQXV0aGVudGljYXRvckNvbnRleHQucHJvdG90eXBlLm1ldGhvZHMgPSBmdW5jdGlvbihhdXRoZW50aWNhdG9ySWQsIHRva2VuT2JqKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMiAgJiYgdGhpcy5jb25maWcuZmxvd1R5cGUgIT09ICdJbXBsaWNpdCcpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFZlcmlmeUVycm9yKEFVVEhFTlRJQ0FUT1JfQ09OVEVYVF9FUlJPUiwgJ21ldGhvZHMoYXV0aGVudGljYXRvcklkLCB0b2tlbiksIDIgcGFyYW1ldGVycyBhcmUgcmVxdWlyZWQgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHdlcmUgZ2l2ZW4nKSk7XG4gIH1cbiAgXG4gIGxldCB0b2tlbiA9IHRva2VuT2JqIHx8IHRoaXMudG9rZW47XG4gIGxldCBlbmNvZGVkVmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQoYGF0dHJpYnV0ZXMvYXV0aGVudGljYXRvcklkPVwiJHthdXRoZW50aWNhdG9ySWR9XCJgKTtcbiAgbGV0IHBhdGggPSBgJHt0aGlzLmNvbmZpZy50ZW5hbnRVcmx9L3YxLjAvYXV0aG5tZXRob2RzL3NpZ25hdHVyZXM/c2VhcmNoPSR7ZW5jb2RlZFZhbHVlfWA7XG4gIGxldCBvcHRpb25zID0ge1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgdXJsOiBwYXRoXG4gIH07XG5cbiAgcmV0dXJuIHRoaXMuX2hhbmRsZVJlc3BvbnNlKG9wdGlvbnMsIHRva2VuKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEF1dGhlbnRpY2F0b3JDb250ZXh0O1xuIl19