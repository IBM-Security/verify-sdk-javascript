"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0,require("@babel/polyfill");var _queryString=_interopRequireDefault(require("query-string")),_Errors=require("./errors/Errors"),_StorageHandler=_interopRequireDefault(require("./helpers/StorageHandler")),_config=require("./config"),_apiRequest=_interopRequireDefault(require("./helpers/apiRequest")),_utils=_interopRequireDefault(require("./helpers/utils"));function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}function _get(a,b,c){return _get="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(a,b,c){var d=_superPropBase(a,b);if(d){var e=Object.getOwnPropertyDescriptor(d,b);return e.get?e.get.call(c):e.value}},_get(a,b,c||a)}function _superPropBase(a,b){for(;!Object.prototype.hasOwnProperty.call(a,b)&&(a=_getPrototypeOf(a),null!==a););return a}function _possibleConstructorReturn(a,b){return b&&("object"===_typeof(b)||"function"==typeof b)?b:_assertThisInitialized(a)}function _assertThisInitialized(a){if(void 0===a)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return a}function _getPrototypeOf(a){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(a){return a.__proto__||Object.getPrototypeOf(a)},_getPrototypeOf(a)}function _inherits(a,b){if("function"!=typeof b&&null!==b)throw new TypeError("Super expression must either be null or a function");a.prototype=Object.create(b&&b.prototype,{constructor:{value:a,writable:!0,configurable:!0}}),b&&_setPrototypeOf(a,b)}function _setPrototypeOf(a,b){return _setPrototypeOf=Object.setPrototypeOf||function(a,b){return a.__proto__=b,a},_setPrototypeOf(a,b)}function _typeof(a){return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},_typeof(a)}function asyncGeneratorStep(a,b,c,d,e,f,g){try{var h=a[f](g),i=h.value}catch(a){return void c(a)}h.done?b(i):Promise.resolve(i).then(d,e)}function _asyncToGenerator(a){return function(){var b=this,c=arguments;return new Promise(function(d,e){function f(a){asyncGeneratorStep(h,d,e,f,g,"next",a)}function g(a){asyncGeneratorStep(h,d,e,f,g,"throw",a)}var h=a.apply(b,c);f(void 0)})}}function _defineProperties(a,b){for(var c,d=0;d<b.length;d++)c=b[d],c.enumerable=c.enumerable||!1,c.configurable=!0,"value"in c&&(c.writable=!0),Object.defineProperty(a,c.key,c)}function _createClass(a,b,c){return b&&_defineProperties(a.prototype,b),c&&_defineProperties(a,c),a}function _classCallCheck(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}var FLOW_TYPE={implicitFlow:"implicit",authorizationCodeFlow:"authorization",deviceFlow:"device",ROPC:"ropc"},OAuthContext=function a(b){if(_classCallCheck(this,a),!b)throw new _Errors.InvalidOAuthConfigurationError("Config parameter is required");if(!b.flowType)throw new _Errors.InvalidOAuthConfigurationError("flowType property is required in config settings");if(!b.clientId)throw new _Errors.InvalidOAuthConfigurationError("clientId property is required in config settings");if(!(b.tenantUrl&&_utils.default.isUrl(b.tenantUrl)))throw new _Errors.InvalidOAuthConfigurationError("a valid tenantUrl property is required in config settings");if(!b.scope)throw new _Errors.InvalidOAuthConfigurationError("scope property is required in config settings");// if (!config.responseType) {
// 	throw new InvalidOAuthConfigurationError('responseType property is required in config settings');
// }
switch(b.flowType){case FLOW_TYPE.implicitFlow:return new ImplicitFlow(b);case FLOW_TYPE.authorizationCodeFlow:return new AuthorizationCodeFlow(b);case FLOW_TYPE.deviceFlow:return new DeviceFlow(b);case FLOW_TYPE.ROPC:return new ROPCFlow(b);default:var c=Object.values(FLOW_TYPE).map(function(a){return" \"".concat(a,"\"")});throw new _Errors.InvalidOAuthConfigurationError("\"".concat(b.flowType,"\" flowType not valid. Valid flow types are: ").concat(c));}},FlowAbstract=/*#__PURE__*/function(){function a(b){// cannot instantiate abstract class
if(_classCallCheck(this,a),(this instanceof a?this.constructor:void 0)===a)throw new TypeError("Cannot instantiate FlowAbstract directly");this.config=b}/**
	 * @abstract
	 * @function isValidConfig Validates the config of an OAuthContext instance
	 * @returns {boolean} Boolean indicating whether the config is valid
	 * Abstract parent method throws AbstractMethodNotImplementedError()
	 */return _createClass(a,[{key:"isValidConfig",value:function isValidConfig(){throw new _Errors.AbstractMethodNotImplementedError}/**
	 * @function logout Revokes a user's current access token
	 * @param {string} path Optional path
	 * @param {object} token The token to be revoked containing access_token, refresh_token ...
	 * @returns {Promise<object>} Response object from revoking the token
	 */},{key:"logout",value:function logout(a,b){// path and token supplied
if(2===arguments.length&&!this.isToken(b))return Promise.reject(new _Errors.VerifyError(_config.AppConfig.TOKEN_ERROR,"Token parameter is not a valid token"));// no path but a 'token' provided
if(1===arguments.length&&!this.isToken(a))return Promise.reject(new _Errors.VerifyError(_config.AppConfig.TOKEN_ERROR,"Token parameter is not a valid token"));try{return 2===arguments.length?this.revokeToken(b,"access_token"):this.revokeToken(a,"access_token")}catch(a){return Promise.reject(a)}}/**
	 * @function getConfig Gets the config of the current OAuthContext instance
	 * @returns {object} The config object containing clientId, redirectUri, flowType, ...
	 */},{key:"getConfig",value:function getConfig(){return this.config}/**
	 * @function isAuthenticated Checks whether a token is still valid
	 * @param {object} token The token to be checked for active status containing access_token, refresh_token ...
	 * @returns {Promise<boolean>} Boolean indicating whether the token is active
	 */},{key:"isAuthenticated",value:function(){var a=_asyncToGenerator(/*#__PURE__*/regeneratorRuntime.mark(function a(b){var c;return regeneratorRuntime.wrap(function(a){for(;;)switch(a.prev=a.next){case 0:return a.prev=0,a.next=3,this.introspectToken(b);case 3:return c=a.sent,a.abrupt("return",this.config.flowType===FLOW_TYPE.implicitFlow?!0===c.active:!0===c.response.active);case 7:return a.prev=7,a.t0=a["catch"](0),a.abrupt("return",Promise.reject(a.t0));case 10:case"end":return a.stop();}},a,this,[[0,7]])}));return function isAuthenticated(){return a.apply(this,arguments)}}()/**
	 * @function introspectToken Introspects a token for more information
	 * @param {object} token The token to be inspected containing access_token, refresh_token ...
	 * @returns {Promise<object>} Response object with information about the supplied token
	 */},{key:"introspectToken",value:function introspectToken(a){if(!this.isToken(a))return Promise.reject(new _Errors.VerifyError(_config.AppConfig.TOKEN_ERROR,"Token parameter is not a valid token"));var b="".concat(this.config.tenantUrl,"/v1.0/endpoint/default/introspect"),c={client_id:this.config.clientId,client_secret:this.config.clientSecret,token:a.access_token},d=_queryString.default.stringify(c);return this.handleResponse({method:"POST",url:b,contentType:"application/x-www-form-urlencoded",data:d},a)}/**
	 * @function userInfo Retrieves user information associated with the given token
	 * @param {object} token The associated token to inspect the user information of containing access_token, refresh_token ...
	 * @returns {Promise<object>} Response object with information about the user of the supplied token
	 */},{key:"userInfo",value:function userInfo(a){if(!this.isToken(a))return Promise.reject(new _Errors.VerifyError(_config.AppConfig.TOKEN_ERROR,"Token parameter is not a valid token"));var b="".concat(this.config.tenantUrl,"/v1.0/endpoint/default/userinfo"),c={method:"POST",url:b,contentType:"application/x-www-form-urlencoded",data:_queryString.default.stringify({access_token:a.access_token})};return this.handleResponse(c,a)}/**
	 * @function isToken Validates a token
	 * @param {object} token The token to check containing access_token, refresh_token ...
	 * @returns {boolean} Boolean indicating whether the token is valid
	 */},{key:"isToken",value:function isToken(a){return a&&a.access_token}/**
	 * @function revokeToken Revokes a token
	 * @param {object} token The token to be revoked containing access_token, refresh_token ...
	 * @param {string} tokenType The type of token - 'access_token' or 'refresh_token'
	 * @returns {Promise<object>} Response object from revoking the token
	 */},{key:"revokeToken",value:function revokeToken(a,b){var c="".concat(this.config.tenantUrl,"/v1.0/endpoint/default/revoke");if(2>arguments.length)throw new _Errors.VerifyError(_config.AppConfig.OAUTH_CONTEXT_API_ERROR,"revokeToken(token, tokenType), 2 parameters are required "+arguments.length+" were given");if(!a)throw new _Errors.VerifyError(_config.AppConfig.OAUTH_CONTEXT_API_ERROR,"token cannot be null");if("access_token"!==b&&"refresh_token"!==b)throw new _Errors.VerifyError(_config.AppConfig.OAUTH_CONTEXT_API_ERROR,"Parameter: ".concat(b," is invalid.\n Supported values are \"access_token\" or \"refresh_token"));var d="access_token"===b?a.access_token:a.refresh_token,e={client_id:this.config.clientId,client_secret:this.config.clientSecret,token:d},f=_queryString.default.stringify(e);// token is not required, but handleResponse will throw error without it
return this.handleResponse({method:"POST",contentType:"application/x-www-form-urlencoded",url:c,data:f},a)}/**
	 * @function parseUrlHash Parses a url hash string into an object
	 * @param {string} hash The hash to be parsed
	 * @returns {object} The object representation of the hash string
	 */},{key:"_parseUrlHash",value:function _parseUrlHash(a){return _queryString.default.parse(a)}/**
	 * @function getToken Makes an api request to the Cloud Identity Authorization server
	 * to retrieve access_token, refresh_token, grant_id... used for NodeJS applications that can
	 * store secure credentials
	 * @param {object} params Required data and url path to token EP to retrieve a OAuth 2.0 Bearer Token.
	 * @returns {Promise<object>} Response object containing access token
	 */},{key:"getToken",value:function getToken(a){var b=a.data,c=a.path;if(!(b&&"object"===_typeof(b)&&b.constructor===Object||b&&"string"==typeof b&&b.includes("?")))throw new _Errors.VerifyError(_config.AppConfig.OAUTH_CONTEXT_API_ERROR,"getToken(params), Params must contain data object or query string");b.client_id=this.config.clientId,b.client_secret=this.config.clientSecret,b.scope=this.config.scope,b.grant_type=this.config.grantType,this.config.flowType===FLOW_TYPE.authorizationCodeFlow&&(b.redirect_uri=this.config.redirectUri);var d=_queryString.default.stringify(b);return(0,_apiRequest.default)({method:"POST",url:c,contentType:"application/x-www-form-urlencoded",data:d})}/**
	 * @abstract
	 * @function refreshToken Refreshes a token if it has expired
	 * @param {object} token The token object to be refreshed containing access_token, refresh_token ...
	 * @returns {Promise<object|void>} Response object from refreshing the token
	 */},{key:"refreshToken",value:function refreshToken(a){if(!a.hasOwnProperty("refresh_token"))return Promise.reject(new _Errors.VerifyError(_config.AppConfig.OAUTH_CONTEXT_API_ERROR,"token has no refresh_token property"));var b="".concat(this.config.tenantUrl,"/v1.0/endpoint/default/token"),c={refresh_token:a.refresh_token,client_id:this.config.clientId,client_secret:this.config.clientSecret,grant_type:"refresh_token",scope:this.config.scope},d=_queryString.default.stringify(c);return(0,_apiRequest.default)({method:"POST",url:b,contentType:"application/x-www-form-urlencoded",data:d})}/**
	 * @function authorize Builds authorization URL using provided config
	 * @param {object} options Config object with clientId, redirectUri, scope and responseType to authorize against
	 * @returns {string} Authorization URL
	 */},{key:"_authorize",value:function _authorize(a){return this._buildUrl(a)}/**
	 * @function buildUrl Constructs authorization URL given provided options
	 * @param {object} options Config object with clientId, redirectUri, scope and responseType
	 * @returns {string} Authorization URL
	 */},{key:"_buildUrl",value:function _buildUrl(a){return a.tenantUrl+"/oidc/endpoint/default/authorize?"+_queryString.default.stringify({client_id:a.clientId,redirect_uri:a.redirectUri,scope:a.scope,response_type:a.responseType,state:_utils.default.randomString(16),nonce:_utils.default.randomString(16)})}/**
	 * @function handleResponse Makes a request and refreshes token if token is expired
	 * @param {object} options Request object containing url path, method, responseType, accept, data to make a valid apiRequest
	 * @param {object} tokenObj Token object containing access_token, refresh_token ... used to make the request
	 * @returns {object} Response object from the request
	 */},{key:"handleResponse",value:function(){var a=_asyncToGenerator(/*#__PURE__*/regeneratorRuntime.mark(function a(b,c){var d,e,f,g,h,i=arguments;return regeneratorRuntime.wrap(function(a){for(;;)switch(a.prev=a.next){case 0:if(!(2>i.length)){a.next=2;break}return a.abrupt("return",Promise.reject(new _Errors.VerifyError(_config.AppConfig.OAUTH_CONTEXT_API_ERROR,"handleResponse(options, token), 2 parameters are required "+i.length+" were given")));case 2:if(this.isToken(c)){a.next=4;break}return a.abrupt("return",Promise.reject(new _Errors.VerifyError(_config.AppConfig.TOKEN_ERROR,"Token parameter is not a valid token")));case 4:return d=c,e={response:null,token:null},a.prev=6,a.next=9,(0,_apiRequest.default)(b,d.access_token);case 9:if(f=a.sent,e.response=f,this.config.flowType!==FLOW_TYPE.implicitFlow){a.next=13;break}return a.abrupt("return",Promise.resolve(f));case 13:return a.abrupt("return",Promise.resolve(e));case 16:if(a.prev=16,a.t0=a["catch"](6),!(401===a.t0.status&&_utils.default.isNode())){a.next=29;break}if(d.refresh_token){a.next=21;break}return a.abrupt("return",Promise.reject(new _Errors.VerifyError(_config.AppConfig.OAUTH_CONTEXT_API_ERROR,"access_token expired and refresh_token not found")));case 21:return a.next=23,this.refreshToken(d);case 23:return g=a.sent,a.next=26,(0,_apiRequest.default)(b,g.access_token);case 26:return h=a.sent,e={response:h,token:g},a.abrupt("return",Promise.resolve(e));case 29:return a.abrupt("return",Promise.reject(a.t0));case 30:case"end":return a.stop();}},a,this,[[6,16]])}));return function handleResponse(){return a.apply(this,arguments)}}()}]),a}(),ImplicitFlow=/*#__PURE__*/function(a){function b(a){var c;return _classCallCheck(this,b),c=_possibleConstructorReturn(this,_getPrototypeOf(b).call(this,a)),c.isValidConfig(),c.storageHandler=new _StorageHandler.default(a.storageType),c}/**
	 * @function isValidConfig Validates the config of an ImplicitFlow instance
	 * @returns {boolean} Boolean indicating whether the config is valid
	 * Throws error if no storageType in config or instantiating ImplicitFlow in NodeJS
	 */return _inherits(b,a),_createClass(b,[{key:"isValidConfig",value:function isValidConfig(){if(_utils.default.isNode())throw new _Errors.InvalidOAuthConfigurationError("Implicit flow is not supported in Node");if(!this.config.storageType)throw new _Errors.InvalidOAuthConfigurationError("storageType property is required in config settings for Implicit flow");if(!(this.config.redirectUri&&_utils.default.isUrl(this.config.redirectUri)))throw new _Errors.InvalidOAuthConfigurationError("a valid redirectUri property is required in config settings");return!0}/**
	 * @function refreshToken Refreshes the token if it has expired
	 * @param {object} token The token object containing access_token, refresh_token ...
	 * @returns {Promise<void>} Throws NotAvailableError() as refresh_token is not available in Implicit Flow
	 */},{key:"refreshToken",value:function refreshToken(){throw new _Errors.NotAvailableError}/**
	 * @function fetchToken Retrieves the token object from storage
	 * @returns {object|void} Token object found in storage or throws error
	 */},{key:"fetchToken",value:function fetchToken(){try{return JSON.parse(this.storageHandler.getStorage("token"))}catch(a){return a}}/**
	 * @function setSession Sets the session expiration according to the expiration of the stored token
	 * The token will be cleared from storage once it expires and the session will end.
	 * @returns {void}
	 */},{key:"_setSession",value:function _setSession(){var a=this,b=JSON.parse(this.storageHandler.getStorage("token")).expires_in,c=b-(Date.now()-10);0<c&&setTimeout(function(){a.session=!1,a.storageHandler.clearStorage()},c)}/**
	 * @function login Builds a login URL to authorize against using the instance's config
	 * @returns {string} Authorization URL
	 */},{key:"login",value:function login(){return this._authorize(this.config)}/**
	 * @function logout Redirects user after accessToken has expired.
	 * @params {string} path Optional path to redirect to, defaults to index page.
	 */},{key:"logout",value:function(){var a=_asyncToGenerator(/*#__PURE__*/regeneratorRuntime.mark(function a(b){var c;return regeneratorRuntime.wrap(function(a){for(;;)switch(a.prev=a.next){case 0:return c=this.fetchToken(),a.next=3,this.revokeToken(c,"access_token");case 3:return a.next=5,this.storageHandler.clearStorage();case 5:return a.next=7,window.location.replace(b||"/");case 7:case"end":return a.stop();}},a,this)}));return function logout(){return a.apply(this,arguments)}}()/**
	 * @function handleCallback Stores token into sessionStorage
	 * @returns {Promise<void>} Promise rejection if error
	 */},{key:"handleCallback",value:function handleCallback(){var a,b=/#error/,c=window.location.hash;return a="object"===_typeof(c)?c:this._parseUrlHash(c),new Promise(function(d){b.test(c)?d(a):(this.storageHandler.setStorage(a),this._setSession(),window.location.hash="")}.bind(this))}}]),b}(FlowAbstract),AuthorizationCodeFlow=/*#__PURE__*/function(a){function b(a){var c;return _classCallCheck(this,b),c=_possibleConstructorReturn(this,_getPrototypeOf(b).call(this,a)),c.isValidConfig(),c.config.grantType="authorization_code",c}/**
	 * @function isValidConfig Validates the config of an AuthorizationCodeFlow instance
	 * @returns {boolean} Boolean indicating whether the config is valid
	 * Throws error if no clientSecret in config
	 */return _inherits(b,a),_createClass(b,[{key:"isValidConfig",value:function isValidConfig(){if(!this.config.clientSecret)throw new _Errors.InvalidOAuthConfigurationError("clientSecret property is required in config settings for Authorization Code flow");if(!(this.config.redirectUri&&_utils.default.isUrl(this.config.redirectUri)))throw new _Errors.InvalidOAuthConfigurationError("a valid redirectUri property is required in config settings");if(!this.config.responseType)throw new _Errors.InvalidOAuthConfigurationError("responseType property is required in config settings");return!0}},{key:"getToken",value:function getToken(a){if(!a)throw new _Errors.VerifyError(_config.AppConfig.OAUTH_CONTEXT_CONFIG_SETTINGS_ERROR,"getToken(params), Params are required");if(!(a&&"string"==typeof a&&a.includes("?")))throw new _Errors.VerifyError(_config.AppConfig.OAUTH_CONTEXT_API_ERROR,"getToken(params), Params must contain data object or query string");var b=a.substring(a.indexOf("?")),c="object"===_typeof(b)?b:_queryString.default.parse(b),d="".concat(this.config.tenantUrl,"/v1.0/endpoint/default/token");c.redirect_uri=this.config.redirectUri,c.grant_type=this.config.grantType,c.client_id=this.config.clientId,c.client_secret=this.config.clientSecret,c.scope=this.config.scope;var e=_queryString.default.stringify(c);return(0,_apiRequest.default)({method:"POST",url:d,contentType:"application/x-www-form-urlencoded",data:e})}/**
	 * @function authenticate Returns a URL used to authenticate against using the instance's config
	 * @returns {Promise<string>} Authentication URL
	 */},{key:"authenticate",value:function authenticate(){return new Promise(function(a){a(this._authorize(this.config))}.bind(this))}/**
	 * @function refreshToken Refreshes a token if it has expired
	 * @param {object} token The token object to be refreshed containing access_token, refresh_token ...
	 * @returns {Promise<object|void>} Response object from refreshing the token
	 */},{key:"refreshToken",value:function refreshToken(a){return _get(_getPrototypeOf(b.prototype),"refreshToken",this).call(this,a)}}]),b}(FlowAbstract),DeviceFlow=/*#__PURE__*/function(a){function b(a){var c;return _classCallCheck(this,b),c=_possibleConstructorReturn(this,_getPrototypeOf(b).call(this,a)),c.isValidConfig(),c.POLLING_TIME=5e3,c.config.grantType="urn:ietf:params:oauth:grant-type:device_code",c}/**
	 * @function isValidConfig Validates the config of an DeviceFlow instance
	 * @returns {boolean} Boolean indicating whether the config is valid
	 */return _inherits(b,a),_createClass(b,[{key:"isValidConfig",value:function isValidConfig(){if(!this.config.clientSecret)throw new _Errors.InvalidOAuthConfigurationError("clientSecret property is required in config settings for  Code flow");return!0}/**
	 * @function authorize used to initiate request at /device_authorize EP with
	 * client id (and scope if provided)
	 * @returns The successful response returned includes a device_code, user_code and verification_uri.
	 * Note: device_code should not be exposed to the user agent.
	 */},{key:"authorize",value:function authorize(){var a="".concat(this.config.tenantUrl,"/oidc/endpoint/default/device_authorization"),b={client_id:this.config.clientId,scope:this.config.scope},c=_queryString.default.stringify(b);return(0,_apiRequest.default)({method:"POST",url:a,contentType:"application/x-www-form-urlencoded",data:c})}/**
	 * @function pollTokenApi Polling the token endpoint of the authorization server
	 * @param {deviceCode} string used for polling the token EP
	 * @param {duration} number Optional, used to set the polling time in milliseconds. Default 5000 milliseconds.
	 * @returns {Promise<object>} Resolved or Rejected promise.
	 */},{key:"pollTokenApi",value:function(){var a=_asyncToGenerator(/*#__PURE__*/regeneratorRuntime.mark(function a(b){var c,d,e,f,g,h=arguments;return regeneratorRuntime.wrap(function(a){for(;;)switch(a.prev=a.next){case 0:if(c=1<h.length&&void 0!==h[1]?h[1]:this.POLLING_TIME,!(c<this.POLLING_TIME)){a.next=3;break}return a.abrupt("return",Promise.reject(new _Errors.DeveloperError("The device made an attempt within [5] seconds. This request will not be processed.")));case 3:if(b){a.next=5;break}return a.abrupt("return",Promise.reject(new _Errors.DeveloperError("No device code value provided.")));case 5:d="".concat(this.config.tenantUrl,"/v1.0/endpoint/default/token"),f={client_id:this.config.clientId,client_secret:this.config.clientSecret,grant_type:this.config.grantType,device_code:b},g={messageId:""};case 8:if("expired_token"===g.messageId||e){a.next=23;break}return a.prev=9,a.next=12,this.getToken({data:f,path:d});case 12:return e=a.sent,a.abrupt("break",23);case 16:a.prev=16,a.t0=a["catch"](9),g=a.t0;case 19:return a.next=21,_utils.default.sleep(c);case 21:a.next=8;break;case 23:if(!e){a.next=25;break}return a.abrupt("return",Promise.resolve());case 25:return a.abrupt("return",Promise.reject(g.messageDescription));case 26:case"end":return a.stop();}},a,this,[[9,16]])}));return function pollTokenApi(){return a.apply(this,arguments)}}()/**
	 * @function refreshToken Refreshes a token if it has expired
	 * @param {object} token The token object to be refreshed containing access_token, refresh_token ...
	 * @returns {Promise<object|void>} Response object from refreshing the token
	 */},{key:"refreshToken",value:function refreshToken(a){return _get(_getPrototypeOf(b.prototype),"refreshToken",this).call(this,a)}}]),b}(FlowAbstract),ROPCFlow=/*#__PURE__*/function(a){function b(a){var c;return _classCallCheck(this,b),c=_possibleConstructorReturn(this,_getPrototypeOf(b).call(this,a)),c.isValidConfig(),c.config.grantType="password",c}/**
	 * @function isValidConfig Validates the config of a DeviceFlow instance
	 * @returns {boolean} Boolean indicating whether the config is valid
	 */return _inherits(b,a),_createClass(b,[{key:"isValidConfig",value:function isValidConfig(){return!0}/**
	 * @function login Retrieves a token using the supplied credentials
	 * @param {string} username The user's identifier
	 * @param {string} password The user's password
	 * @returns {Promise<object>} Response object from login containing token
	 */},{key:"login",value:function login(a,b){if(!a||!b)return Promise.reject(new _Errors.DeveloperError("username and password params are required"));var c="".concat(this.config.tenantUrl,"/v1.0/endpoint/default/token"),d={client_id:this.config.clientId,client_secret:this.config.clientSecret,username:a,password:b,grant_type:this.config.grantType,scope:this.config.scope},e=_queryString.default.stringify(d);return(0,_apiRequest.default)({method:"POST",url:c,contentType:"application/x-www-form-urlencoded",data:e})}/**
	 * @function refreshToken Refreshes a token if it has expired
	 * @param {object} token The token object to be refreshed containing access_token, refresh_token ...
	 * @returns {Promise<object|void>} Response object from refreshing the token
	 */},{key:"refreshToken",value:function refreshToken(a){return _get(_getPrototypeOf(b.prototype),"refreshToken",this).call(this,a)}}]),b}(FlowAbstract),_default=OAuthContext;/**
 * @class OAuthContext
 * Uses Factory pattern to create the appropriate class instance based on the flowType
 */exports.default=_default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2xpYi9PQXV0aENvbnRleHQuanMiXSwibmFtZXMiOlsiRkxPV19UWVBFIiwiaW1wbGljaXRGbG93IiwiYXV0aG9yaXphdGlvbkNvZGVGbG93IiwiZGV2aWNlRmxvdyIsIlJPUEMiLCJPQXV0aENvbnRleHQiLCJjb25maWciLCJJbnZhbGlkT0F1dGhDb25maWd1cmF0aW9uRXJyb3IiLCJmbG93VHlwZSIsImNsaWVudElkIiwidGVuYW50VXJsIiwidXRpbHMiLCJpc1VybCIsInNjb3BlIiwiSW1wbGljaXRGbG93IiwiQXV0aG9yaXphdGlvbkNvZGVGbG93IiwiRGV2aWNlRmxvdyIsIlJPUENGbG93IiwiZmxvd1R5cGVzIiwiT2JqZWN0IiwidmFsdWVzIiwibWFwIiwidmFsdWUiLCJGbG93QWJzdHJhY3QiLCJUeXBlRXJyb3IiLCJBYnN0cmFjdE1ldGhvZE5vdEltcGxlbWVudGVkRXJyb3IiLCJwYXRoIiwidG9rZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJpc1Rva2VuIiwiUHJvbWlzZSIsInJlamVjdCIsIlZlcmlmeUVycm9yIiwiQXBwQ29uZmlnIiwiVE9LRU5fRVJST1IiLCJyZXZva2VUb2tlbiIsImVycm9yIiwiaW50cm9zcGVjdFRva2VuIiwicGF5bG9hZCIsImFjdGl2ZSIsInJlc3BvbnNlIiwiZGF0YSIsImNsaWVudF9pZCIsImNsaWVudF9zZWNyZXQiLCJjbGllbnRTZWNyZXQiLCJhY2Nlc3NfdG9rZW4iLCJlbmNvZGVkRGF0YSIsInFzIiwic3RyaW5naWZ5IiwiaGFuZGxlUmVzcG9uc2UiLCJtZXRob2QiLCJ1cmwiLCJjb250ZW50VHlwZSIsIm9wdGlvbnMiLCJ0b2tlblR5cGUiLCJPQVVUSF9DT05URVhUX0FQSV9FUlJPUiIsImV4cGlyZVRva2VuIiwicmVmcmVzaF90b2tlbiIsImhhc2giLCJwYXJzZSIsInBhcmFtcyIsImNvbnN0cnVjdG9yIiwiaW5jbHVkZXMiLCJncmFudF90eXBlIiwiZ3JhbnRUeXBlIiwicmVkaXJlY3RfdXJpIiwicmVkaXJlY3RVcmkiLCJoYXNPd25Qcm9wZXJ0eSIsIl9idWlsZFVybCIsInJlc3BvbnNlX3R5cGUiLCJyZXNwb25zZVR5cGUiLCJzdGF0ZSIsInJhbmRvbVN0cmluZyIsIm5vbmNlIiwidG9rZW5PYmoiLCJyZXNvbHZlIiwic3RhdHVzIiwiaXNOb2RlIiwicmVmcmVzaFRva2VuIiwibmV3VG9rZW4iLCJvcmlnaW5hbFJlcXVlc3QiLCJpc1ZhbGlkQ29uZmlnIiwic3RvcmFnZUhhbmRsZXIiLCJTdG9yYWdlSGFuZGxlciIsInN0b3JhZ2VUeXBlIiwiTm90QXZhaWxhYmxlRXJyb3IiLCJKU09OIiwiZ2V0U3RvcmFnZSIsImV4cGlyZXNBdCIsImV4cGlyZXNfaW4iLCJkZWxheSIsIkRhdGUiLCJub3ciLCJzZXRUaW1lb3V0Iiwic2Vzc2lvbiIsImNsZWFyU3RvcmFnZSIsIl9hdXRob3JpemUiLCJhY2Nlc3NUb2tlbiIsImZldGNoVG9rZW4iLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInJlcGxhY2UiLCJ1cmxPYmoiLCJlcnJvckNoZWNrIiwiX3BhcnNlVXJsSGFzaCIsInRlc3QiLCJzZXRTdG9yYWdlIiwiX3NldFNlc3Npb24iLCJiaW5kIiwiT0FVVEhfQ09OVEVYVF9DT05GSUdfU0VUVElOR1NfRVJST1IiLCJxdWVyeSIsInN1YnN0cmluZyIsImluZGV4T2YiLCJQT0xMSU5HX1RJTUUiLCJhdXRoU2VydmVyUGF0aCIsImRldmljZUNvZGUiLCJkdXJhdGlvbiIsIkRldmVsb3BlckVycm9yIiwiZGV2aWNlX2NvZGUiLCJtZXNzYWdlSWQiLCJnZXRUb2tlbiIsInNsZWVwIiwibWVzc2FnZURlc2NyaXB0aW9uIiwidXNlcm5hbWUiLCJwYXNzd29yZCJdLCJtYXBwaW5ncyI6IjBwRkFnQk1BLENBQUFBLFNBQVMsQ0FBRyxDQUNkQyxZQUFZLENBQUUsVUFEQSxDQUVkQyxxQkFBcUIsQ0FBRSxlQUZULENBR2RDLFVBQVUsQ0FBRSxRQUhFLENBSWRDLElBQUksQ0FBRSxNQUpRLEMsQ0FXWkMsWSxDQUNGLFdBQVlDLENB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YyxDQU9oQmdDLENBQUksQ0FBRyxDQUNUQyxTQUFTLENBQUUsS0FBS3JDLE1BQUwsQ0FBWUcsUUFEZCxDQUVUbUMsYUFBYSxDQUFFLEtBQUt0QyxNQUFMLENBQVl1QyxZQUZsQixDQUdUK0UsUUFBUSxDQUFFQSxDQUhELENBSVRDLFFBQVEsQ0FBRUEsQ0FKRCxDQUtUN0QsVUFBVSxDQUFFLEtBQUsxRCxNQUFMLENBQVkyRCxTQUxmLENBTVRwRCxLQUFLLENBQUUsS0FBS1AsTUFBTCxDQUFZTyxLQU5WLENBUFMsQ0FnQmxCa0MsQ0FBVyxDQUFHQyxxQkFBR0MsU0FBSCxDQUFhUCxDQUFiLENBaEJJLENBeUJ0QixNQUFPLHdCQVBPLENBQ1ZTLE1BQU0sQ0FBRSxNQURFLENBRVZDLEdBQUcsQ0FBRTFCLENBRkssQ0FHVjJCLFdBQVcsQ0FBRSxtQ0FISCxDQUlWWCxJQUFJLENBQUVLLENBSkksQ0FPUCxDQUNWLENBRUo7Ozs7c0RBS2dCcEIsQyxDQUFPLENBQ2hCLHdFQUEwQkEsQ0FBMUIsQ0FDSCxDLE9BeERrQkosWSxXQTJEUmxCLFksQ0E1dEJmIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdAYmFiZWwvcG9seWZpbGwnO1xuaW1wb3J0IHFzIGZyb20gJ3F1ZXJ5LXN0cmluZyc7XG5pbXBvcnQge1xuICAgIFZlcmlmeUVycm9yLFxuICAgIEFic3RyYWN0TWV0aG9kTm90SW1wbGVtZW50ZWRFcnJvcixcbiAgICBJbnZhbGlkT0F1dGhDb25maWd1cmF0aW9uRXJyb3IsXG4gICAgTm90QXZhaWxhYmxlRXJyb3IsXG4gICAgRGV2ZWxvcGVyRXJyb3Jcbn0gZnJvbSAnLi9lcnJvcnMvRXJyb3JzJztcbmltcG9ydCBTdG9yYWdlSGFuZGxlciBmcm9tICcuL2hlbHBlcnMvU3RvcmFnZUhhbmRsZXInO1xuaW1wb3J0IHtcbiAgICBBcHBDb25maWdcbn0gZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IGFwaVJlcXVlc3QgZnJvbSAnLi9oZWxwZXJzL2FwaVJlcXVlc3QnO1xuaW1wb3J0IHV0aWxzIGZyb20gJy4vaGVscGVycy91dGlscyc7XG5cbmNvbnN0IEZMT1dfVFlQRSA9IHtcbiAgICBpbXBsaWNpdEZsb3c6ICdpbXBsaWNpdCcsXG4gICAgYXV0aG9yaXphdGlvbkNvZGVGbG93OiAnYXV0aG9yaXphdGlvbicsXG4gICAgZGV2aWNlRmxvdzogJ2RldmljZScsXG4gICAgUk9QQzogJ3JvcGMnXG59O1xuXG4vKipcbiAqIEBjbGFzcyBPQXV0aENvbnRleHRcbiAqIFVzZXMgRmFjdG9yeSBwYXR0ZXJuIHRvIGNyZWF0ZSB0aGUgYXBwcm9wcmlhdGUgY2xhc3MgaW5zdGFuY2UgYmFzZWQgb24gdGhlIGZsb3dUeXBlXG4gKi9cbmNsYXNzIE9BdXRoQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE9BdXRoQ29uZmlndXJhdGlvbkVycm9yKCdDb25maWcgcGFyYW1ldGVyIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25maWcuZmxvd1R5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkT0F1dGhDb25maWd1cmF0aW9uRXJyb3IoJ2Zsb3dUeXBlIHByb3BlcnR5IGlzIHJlcXVpcmVkIGluIGNvbmZpZyBzZXR0aW5ncycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29uZmlnLmNsaWVudElkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE9BdXRoQ29uZmlndXJhdGlvbkVycm9yKCdjbGllbnRJZCBwcm9wZXJ0eSBpcyByZXF1aXJlZCBpbiBjb25maWcgc2V0dGluZ3MnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShjb25maWcudGVuYW50VXJsICYmIHV0aWxzLmlzVXJsKGNvbmZpZy50ZW5hbnRVcmwpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPQXV0aENvbmZpZ3VyYXRpb25FcnJvcignYSB2YWxpZCB0ZW5hbnRVcmwgcHJvcGVydHkgaXMgcmVxdWlyZWQgaW4gY29uZmlnIHNldHRpbmdzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25maWcuc2NvcGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkT0F1dGhDb25maWd1cmF0aW9uRXJyb3IoJ3Njb3BlIHByb3BlcnR5IGlzIHJlcXVpcmVkIGluIGNvbmZpZyBzZXR0aW5ncycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmICghY29uZmlnLnJlc3BvbnNlVHlwZSkge1xuICAgICAgICAvLyBcdHRocm93IG5ldyBJbnZhbGlkT0F1dGhDb25maWd1cmF0aW9uRXJyb3IoJ3Jlc3BvbnNlVHlwZSBwcm9wZXJ0eSBpcyByZXF1aXJlZCBpbiBjb25maWcgc2V0dGluZ3MnKTtcbiAgICAgICAgLy8gfVxuICAgICAgICBzd2l0Y2ggKGNvbmZpZy5mbG93VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBGTE9XX1RZUEUuaW1wbGljaXRGbG93OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW1wbGljaXRGbG93KGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlIEZMT1dfVFlQRS5hdXRob3JpemF0aW9uQ29kZUZsb3c6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBdXRob3JpemF0aW9uQ29kZUZsb3coY29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgRkxPV19UWVBFLmRldmljZUZsb3c6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXZpY2VGbG93KGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlIEZMT1dfVFlQRS5ST1BDOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUk9QQ0Zsb3coY29uZmlnKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc3QgZmxvd1R5cGVzID0gT2JqZWN0LnZhbHVlcyhGTE9XX1RZUEUpLm1hcCh2YWx1ZSA9PiBgIFwiJHt2YWx1ZX1cImApO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkT0F1dGhDb25maWd1cmF0aW9uRXJyb3IoYFwiJHtjb25maWcuZmxvd1R5cGV9XCIgZmxvd1R5cGUgbm90IHZhbGlkLiBWYWxpZCBmbG93IHR5cGVzIGFyZTogJHtmbG93VHlwZXN9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGFic3RyYWN0XG4gKiBAY2xhc3MgRmxvd0Fic3RyYWN0XG4gKiBBbiBhYnN0cmFjdCBjbGFzcyB0aGF0IGRlZmluZXMgYW4gT0F1dGhGbG93IGFuZCB0aGUgb3BlcmF0aW9uc1xuICovXG5jbGFzcyBGbG93QWJzdHJhY3Qge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICAvLyBjYW5ub3QgaW5zdGFudGlhdGUgYWJzdHJhY3QgY2xhc3NcbiAgICAgICAgaWYgKG5ldy50YXJnZXQgPT09IEZsb3dBYnN0cmFjdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGluc3RhbnRpYXRlIEZsb3dBYnN0cmFjdCBkaXJlY3RseScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIH1cblxuXHQvKipcblx0ICogQGFic3RyYWN0XG5cdCAqIEBmdW5jdGlvbiBpc1ZhbGlkQ29uZmlnIFZhbGlkYXRlcyB0aGUgY29uZmlnIG9mIGFuIE9BdXRoQ29udGV4dCBpbnN0YW5jZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbmZpZyBpcyB2YWxpZFxuXHQgKiBBYnN0cmFjdCBwYXJlbnQgbWV0aG9kIHRocm93cyBBYnN0cmFjdE1ldGhvZE5vdEltcGxlbWVudGVkRXJyb3IoKVxuXHQgKi9cbiAgICBpc1ZhbGlkQ29uZmlnKCkge1xuICAgICAgICB0aHJvdyBuZXcgQWJzdHJhY3RNZXRob2ROb3RJbXBsZW1lbnRlZEVycm9yKCk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb24gbG9nb3V0IFJldm9rZXMgYSB1c2VyJ3MgY3VycmVudCBhY2Nlc3MgdG9rZW5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHBhdGggT3B0aW9uYWwgcGF0aFxuXHQgKiBAcGFyYW0ge29iamVjdH0gdG9rZW4gVGhlIHRva2VuIHRvIGJlIHJldm9rZWQgY29udGFpbmluZyBhY2Nlc3NfdG9rZW4sIHJlZnJlc2hfdG9rZW4gLi4uXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IFJlc3BvbnNlIG9iamVjdCBmcm9tIHJldm9raW5nIHRoZSB0b2tlblxuXHQgKi9cbiAgICBsb2dvdXQocGF0aCwgdG9rZW4pIHtcbiAgICAgICAgLy8gcGF0aCBhbmQgdG9rZW4gc3VwcGxpZWRcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgIXRoaXMuaXNUb2tlbih0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVmVyaWZ5RXJyb3IoQXBwQ29uZmlnLlRPS0VOX0VSUk9SLCAnVG9rZW4gcGFyYW1ldGVyIGlzIG5vdCBhIHZhbGlkIHRva2VuJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vIHBhdGggYnV0IGEgJ3Rva2VuJyBwcm92aWRlZFxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiAhdGhpcy5pc1Rva2VuKHBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFZlcmlmeUVycm9yKEFwcENvbmZpZy5UT0tFTl9FUlJPUiwgJ1Rva2VuIHBhcmFtZXRlciBpcyBub3QgYSB2YWxpZCB0b2tlbicpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJldm9rZVRva2VuKHRva2VuLCAnYWNjZXNzX3Rva2VuJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJldm9rZVRva2VuKHBhdGgsICdhY2Nlc3NfdG9rZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvbiBnZXRDb25maWcgR2V0cyB0aGUgY29uZmlnIG9mIHRoZSBjdXJyZW50IE9BdXRoQ29udGV4dCBpbnN0YW5jZVxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgY29uZmlnIG9iamVjdCBjb250YWluaW5nIGNsaWVudElkLCByZWRpcmVjdFVyaSwgZmxvd1R5cGUsIC4uLlxuXHQgKi9cblxuICAgIGdldENvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uIGlzQXV0aGVudGljYXRlZCBDaGVja3Mgd2hldGhlciBhIHRva2VuIGlzIHN0aWxsIHZhbGlkXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0b2tlbiBUaGUgdG9rZW4gdG8gYmUgY2hlY2tlZCBmb3IgYWN0aXZlIHN0YXR1cyBjb250YWluaW5nIGFjY2Vzc190b2tlbiwgcmVmcmVzaF90b2tlbiAuLi5cblx0ICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSB0b2tlbiBpcyBhY3RpdmVcblx0ICovXG4gICAgYXN5bmMgaXNBdXRoZW50aWNhdGVkKHRva2VuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5pbnRyb3NwZWN0VG9rZW4odG9rZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmZsb3dUeXBlID09PSBGTE9XX1RZUEUuaW1wbGljaXRGbG93ID8gcGF5bG9hZC5hY3RpdmUgPT09IHRydWUgOiBwYXlsb2FkLnJlc3BvbnNlLmFjdGl2ZSA9PT0gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvbiBpbnRyb3NwZWN0VG9rZW4gSW50cm9zcGVjdHMgYSB0b2tlbiBmb3IgbW9yZSBpbmZvcm1hdGlvblxuXHQgKiBAcGFyYW0ge29iamVjdH0gdG9rZW4gVGhlIHRva2VuIHRvIGJlIGluc3BlY3RlZCBjb250YWluaW5nIGFjY2Vzc190b2tlbiwgcmVmcmVzaF90b2tlbiAuLi5cblx0ICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gUmVzcG9uc2Ugb2JqZWN0IHdpdGggaW5mb3JtYXRpb24gYWJvdXQgdGhlIHN1cHBsaWVkIHRva2VuXG5cdCAqL1xuICAgIGludHJvc3BlY3RUb2tlbih0b2tlbikge1xuICAgICAgICBpZiAoIXRoaXMuaXNUb2tlbih0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVmVyaWZ5RXJyb3IoQXBwQ29uZmlnLlRPS0VOX0VSUk9SLCAnVG9rZW4gcGFyYW1ldGVyIGlzIG5vdCBhIHZhbGlkIHRva2VuJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHBhdGggPSBgJHt0aGlzLmNvbmZpZy50ZW5hbnRVcmx9L3YxLjAvZW5kcG9pbnQvZGVmYXVsdC9pbnRyb3NwZWN0YDtcblxuICAgICAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgICAgIGNsaWVudF9pZDogdGhpcy5jb25maWcuY2xpZW50SWQsXG4gICAgICAgICAgICBjbGllbnRfc2VjcmV0OiB0aGlzLmNvbmZpZy5jbGllbnRTZWNyZXQsXG4gICAgICAgICAgICB0b2tlbjogdG9rZW4uYWNjZXNzX3Rva2VuXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IGVuY29kZWREYXRhID0gcXMuc3RyaW5naWZ5KGRhdGEpO1xuXG4gICAgICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB1cmw6IHBhdGgsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICBkYXRhOiBlbmNvZGVkRGF0YVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKG9wdGlvbnMsIHRva2VuKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvbiB1c2VySW5mbyBSZXRyaWV2ZXMgdXNlciBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHRva2VuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0b2tlbiBUaGUgYXNzb2NpYXRlZCB0b2tlbiB0byBpbnNwZWN0IHRoZSB1c2VyIGluZm9ybWF0aW9uIG9mIGNvbnRhaW5pbmcgYWNjZXNzX3Rva2VuLCByZWZyZXNoX3Rva2VuIC4uLlxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBSZXNwb25zZSBvYmplY3Qgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdXNlciBvZiB0aGUgc3VwcGxpZWQgdG9rZW5cblx0ICovXG4gICAgdXNlckluZm8odG9rZW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVG9rZW4odG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFZlcmlmeUVycm9yKEFwcENvbmZpZy5UT0tFTl9FUlJPUiwgJ1Rva2VuIHBhcmFtZXRlciBpcyBub3QgYSB2YWxpZCB0b2tlbicpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwYXRoID0gYCR7dGhpcy5jb25maWcudGVuYW50VXJsfS92MS4wL2VuZHBvaW50L2RlZmF1bHQvdXNlcmluZm9gO1xuXG4gICAgICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB1cmw6IHBhdGgsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICBkYXRhOiBxcy5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbjogdG9rZW4uYWNjZXNzX3Rva2VuXG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKG9wdGlvbnMsIHRva2VuKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvbiBpc1Rva2VuIFZhbGlkYXRlcyBhIHRva2VuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0b2tlbiBUaGUgdG9rZW4gdG8gY2hlY2sgY29udGFpbmluZyBhY2Nlc3NfdG9rZW4sIHJlZnJlc2hfdG9rZW4gLi4uXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgdG9rZW4gaXMgdmFsaWRcblx0ICovXG4gICAgaXNUb2tlbih0b2tlbikge1xuICAgICAgICByZXR1cm4gISghdG9rZW4gfHwgIXRva2VuLmFjY2Vzc190b2tlbik7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb24gcmV2b2tlVG9rZW4gUmV2b2tlcyBhIHRva2VuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0b2tlbiBUaGUgdG9rZW4gdG8gYmUgcmV2b2tlZCBjb250YWluaW5nIGFjY2Vzc190b2tlbiwgcmVmcmVzaF90b2tlbiAuLi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRva2VuVHlwZSBUaGUgdHlwZSBvZiB0b2tlbiAtICdhY2Nlc3NfdG9rZW4nIG9yICdyZWZyZXNoX3Rva2VuJ1xuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBSZXNwb25zZSBvYmplY3QgZnJvbSByZXZva2luZyB0aGUgdG9rZW5cblx0ICovXG4gICAgcmV2b2tlVG9rZW4odG9rZW4sIHRva2VuVHlwZSkge1xuICAgICAgICBjb25zdCBwYXRoID0gYCR7dGhpcy5jb25maWcudGVuYW50VXJsfS92MS4wL2VuZHBvaW50L2RlZmF1bHQvcmV2b2tlYDtcblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBWZXJpZnlFcnJvcihBcHBDb25maWcuT0FVVEhfQ09OVEVYVF9BUElfRVJST1IsICdyZXZva2VUb2tlbih0b2tlbiwgdG9rZW5UeXBlKSwgMiBwYXJhbWV0ZXJzIGFyZSByZXF1aXJlZCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgd2VyZSBnaXZlbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFZlcmlmeUVycm9yKEFwcENvbmZpZy5PQVVUSF9DT05URVhUX0FQSV9FUlJPUiwgJ3Rva2VuIGNhbm5vdCBiZSBudWxsJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISh0b2tlblR5cGUgPT09ICdhY2Nlc3NfdG9rZW4nIHx8IHRva2VuVHlwZSA9PT0gJ3JlZnJlc2hfdG9rZW4nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFZlcmlmeUVycm9yKEFwcENvbmZpZy5PQVVUSF9DT05URVhUX0FQSV9FUlJPUiwgYFBhcmFtZXRlcjogJHt0b2tlblR5cGV9IGlzIGludmFsaWQuXFxuIFN1cHBvcnRlZCB2YWx1ZXMgYXJlIFwiYWNjZXNzX3Rva2VuXCIgb3IgXCJyZWZyZXNoX3Rva2VuYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBleHBpcmVUb2tlbiA9IHRva2VuVHlwZSA9PT0gJ2FjY2Vzc190b2tlbicgPyB0b2tlbi5hY2Nlc3NfdG9rZW4gOiB0b2tlbi5yZWZyZXNoX3Rva2VuO1xuXG4gICAgICAgIGxldCBkYXRhID0ge1xuICAgICAgICAgICAgY2xpZW50X2lkOiB0aGlzLmNvbmZpZy5jbGllbnRJZCxcbiAgICAgICAgICAgIGNsaWVudF9zZWNyZXQ6IHRoaXMuY29uZmlnLmNsaWVudFNlY3JldCxcbiAgICAgICAgICAgIHRva2VuOiBleHBpcmVUb2tlblxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gcXMuc3RyaW5naWZ5KGRhdGEpO1xuXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgIHVybDogcGF0aCxcbiAgICAgICAgICAgIGRhdGE6IGVuY29kZWREYXRhXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdG9rZW4gaXMgbm90IHJlcXVpcmVkLCBidXQgaGFuZGxlUmVzcG9uc2Ugd2lsbCB0aHJvdyBlcnJvciB3aXRob3V0IGl0XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKG9wdGlvbnMsIHRva2VuKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvbiBwYXJzZVVybEhhc2ggUGFyc2VzIGEgdXJsIGhhc2ggc3RyaW5nIGludG8gYW4gb2JqZWN0XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIFRoZSBoYXNoIHRvIGJlIHBhcnNlZFxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBoYXNoIHN0cmluZ1xuXHQgKi9cbiAgICBfcGFyc2VVcmxIYXNoKGhhc2gpIHtcbiAgICAgICAgcmV0dXJuIHFzLnBhcnNlKGhhc2gpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uIGdldFRva2VuIE1ha2VzIGFuIGFwaSByZXF1ZXN0IHRvIHRoZSBDbG91ZCBJZGVudGl0eSBBdXRob3JpemF0aW9uIHNlcnZlclxuXHQgKiB0byByZXRyaWV2ZSBhY2Nlc3NfdG9rZW4sIHJlZnJlc2hfdG9rZW4sIGdyYW50X2lkLi4uIHVzZWQgZm9yIE5vZGVKUyBhcHBsaWNhdGlvbnMgdGhhdCBjYW5cblx0ICogc3RvcmUgc2VjdXJlIGNyZWRlbnRpYWxzXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgUmVxdWlyZWQgZGF0YSBhbmQgdXJsIHBhdGggdG8gdG9rZW4gRVAgdG8gcmV0cmlldmUgYSBPQXV0aCAyLjAgQmVhcmVyIFRva2VuLlxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBSZXNwb25zZSBvYmplY3QgY29udGFpbmluZyBhY2Nlc3MgdG9rZW5cblx0ICovXG4gICAgZ2V0VG9rZW4ocGFyYW1zKSB7XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhdGhcbiAgICAgICAgfSA9IHBhcmFtcztcbiAgICAgICAgaWYgKCEoKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEuY29uc3RydWN0b3IgPT09IE9iamVjdCkgfHwgKChkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyAmJiBkYXRhLmluY2x1ZGVzKCc/JykpKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBWZXJpZnlFcnJvcihBcHBDb25maWcuT0FVVEhfQ09OVEVYVF9BUElfRVJST1IsICdnZXRUb2tlbihwYXJhbXMpLCBQYXJhbXMgbXVzdCBjb250YWluIGRhdGEgb2JqZWN0IG9yIHF1ZXJ5IHN0cmluZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5jbGllbnRfaWQgPSB0aGlzLmNvbmZpZy5jbGllbnRJZDtcbiAgICAgICAgZGF0YS5jbGllbnRfc2VjcmV0ID0gdGhpcy5jb25maWcuY2xpZW50U2VjcmV0O1xuICAgICAgICBkYXRhLnNjb3BlID0gdGhpcy5jb25maWcuc2NvcGU7XG4gICAgICAgIGRhdGEuZ3JhbnRfdHlwZSA9IHRoaXMuY29uZmlnLmdyYW50VHlwZTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWcuZmxvd1R5cGUgPT09IEZMT1dfVFlQRS5hdXRob3JpemF0aW9uQ29kZUZsb3cpIHtcbiAgICAgICAgICAgIGRhdGEucmVkaXJlY3RfdXJpID0gdGhpcy5jb25maWcucmVkaXJlY3RVcmk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZW5jb2RlZERhdGEgPSBxcy5zdHJpbmdpZnkoZGF0YSk7XG5cbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIHVybDogcGF0aCxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgIGRhdGE6IGVuY29kZWREYXRhXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGFwaVJlcXVlc3Qob3B0aW9ucyk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAYWJzdHJhY3Rcblx0ICogQGZ1bmN0aW9uIHJlZnJlc2hUb2tlbiBSZWZyZXNoZXMgYSB0b2tlbiBpZiBpdCBoYXMgZXhwaXJlZFxuXHQgKiBAcGFyYW0ge29iamVjdH0gdG9rZW4gVGhlIHRva2VuIG9iamVjdCB0byBiZSByZWZyZXNoZWQgY29udGFpbmluZyBhY2Nlc3NfdG9rZW4sIHJlZnJlc2hfdG9rZW4gLi4uXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdHx2b2lkPn0gUmVzcG9uc2Ugb2JqZWN0IGZyb20gcmVmcmVzaGluZyB0aGUgdG9rZW5cblx0ICovXG4gICAgcmVmcmVzaFRva2VuKHRva2VuKSB7XG4gICAgICAgIGlmICghdG9rZW4uaGFzT3duUHJvcGVydHkoJ3JlZnJlc2hfdG9rZW4nKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBWZXJpZnlFcnJvcihBcHBDb25maWcuT0FVVEhfQ09OVEVYVF9BUElfRVJST1IsICd0b2tlbiBoYXMgbm8gcmVmcmVzaF90b2tlbiBwcm9wZXJ0eScpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhdGggPSBgJHt0aGlzLmNvbmZpZy50ZW5hbnRVcmx9L3YxLjAvZW5kcG9pbnQvZGVmYXVsdC90b2tlbmA7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuOiB0b2tlbi5yZWZyZXNoX3Rva2VuLFxuICAgICAgICAgICAgY2xpZW50X2lkOiB0aGlzLmNvbmZpZy5jbGllbnRJZCxcbiAgICAgICAgICAgIGNsaWVudF9zZWNyZXQ6IHRoaXMuY29uZmlnLmNsaWVudFNlY3JldCxcbiAgICAgICAgICAgIGdyYW50X3R5cGU6ICdyZWZyZXNoX3Rva2VuJyxcbiAgICAgICAgICAgIHNjb3BlOiB0aGlzLmNvbmZpZy5zY29wZVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gcXMuc3RyaW5naWZ5KGRhdGEpO1xuXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIHVybDogcGF0aCxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgIGRhdGE6IGVuY29kZWREYXRhXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGFwaVJlcXVlc3Qob3B0aW9ucyk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb24gYXV0aG9yaXplIEJ1aWxkcyBhdXRob3JpemF0aW9uIFVSTCB1c2luZyBwcm92aWRlZCBjb25maWdcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQ29uZmlnIG9iamVjdCB3aXRoIGNsaWVudElkLCByZWRpcmVjdFVyaSwgc2NvcGUgYW5kIHJlc3BvbnNlVHlwZSB0byBhdXRob3JpemUgYWdhaW5zdFxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBBdXRob3JpemF0aW9uIFVSTFxuXHQgKi9cbiAgICBfYXV0aG9yaXplKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkVXJsKG9wdGlvbnMpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uIGJ1aWxkVXJsIENvbnN0cnVjdHMgYXV0aG9yaXphdGlvbiBVUkwgZ2l2ZW4gcHJvdmlkZWQgb3B0aW9uc1xuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBDb25maWcgb2JqZWN0IHdpdGggY2xpZW50SWQsIHJlZGlyZWN0VXJpLCBzY29wZSBhbmQgcmVzcG9uc2VUeXBlXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IEF1dGhvcml6YXRpb24gVVJMXG5cdCAqL1xuICAgIF9idWlsZFVybChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBvcHRpb25zLnRlbmFudFVybCArXG4gICAgICAgICAgICAnL29pZGMvZW5kcG9pbnQvZGVmYXVsdC9hdXRob3JpemU/JyArXG4gICAgICAgICAgICBxcy5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGNsaWVudF9pZDogb3B0aW9ucy5jbGllbnRJZCxcbiAgICAgICAgICAgICAgICByZWRpcmVjdF91cmk6IG9wdGlvbnMucmVkaXJlY3RVcmksXG4gICAgICAgICAgICAgICAgc2NvcGU6IG9wdGlvbnMuc2NvcGUsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VfdHlwZTogb3B0aW9ucy5yZXNwb25zZVR5cGUsXG4gICAgICAgICAgICAgICAgc3RhdGU6IHV0aWxzLnJhbmRvbVN0cmluZygxNiksXG4gICAgICAgICAgICAgICAgbm9uY2U6IHV0aWxzLnJhbmRvbVN0cmluZygxNilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2UgTWFrZXMgYSByZXF1ZXN0IGFuZCByZWZyZXNoZXMgdG9rZW4gaWYgdG9rZW4gaXMgZXhwaXJlZFxuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBSZXF1ZXN0IG9iamVjdCBjb250YWluaW5nIHVybCBwYXRoLCBtZXRob2QsIHJlc3BvbnNlVHlwZSwgYWNjZXB0LCBkYXRhIHRvIG1ha2UgYSB2YWxpZCBhcGlSZXF1ZXN0XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0b2tlbk9iaiBUb2tlbiBvYmplY3QgY29udGFpbmluZyBhY2Nlc3NfdG9rZW4sIHJlZnJlc2hfdG9rZW4gLi4uIHVzZWQgdG8gbWFrZSB0aGUgcmVxdWVzdFxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBSZXNwb25zZSBvYmplY3QgZnJvbSB0aGUgcmVxdWVzdFxuXHQgKi9cbiAgICBhc3luYyBoYW5kbGVSZXNwb25zZShvcHRpb25zLCB0b2tlbk9iaikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVmVyaWZ5RXJyb3IoQXBwQ29uZmlnLk9BVVRIX0NPTlRFWFRfQVBJX0VSUk9SLCAnaGFuZGxlUmVzcG9uc2Uob3B0aW9ucywgdG9rZW4pLCAyIHBhcmFtZXRlcnMgYXJlIHJlcXVpcmVkICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyB3ZXJlIGdpdmVuJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc1Rva2VuKHRva2VuT2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBWZXJpZnlFcnJvcihBcHBDb25maWcuVE9LRU5fRVJST1IsICdUb2tlbiBwYXJhbWV0ZXIgaXMgbm90IGEgdmFsaWQgdG9rZW4nKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b2tlbiA9IHRva2VuT2JqO1xuICAgICAgICAvLyBEZWZpbmUgZW1wdHkgcGF5bG9hZCBvYmplY3RcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICByZXNwb25zZTogbnVsbCxcbiAgICAgICAgICAgIHRva2VuOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpUmVxdWVzdChvcHRpb25zLCB0b2tlbi5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICAgICAgcGF5bG9hZC5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmZsb3dUeXBlID09PSBGTE9XX1RZUEUuaW1wbGljaXRGbG93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBheWxvYWQpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDAxICYmIHV0aWxzLmlzTm9kZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gdmFsaWRhdGUgJ3Rva2VuJyBoYXMgcmVmcmVzaF90b2tlblxuICAgICAgICAgICAgICAgIGlmICghdG9rZW4ucmVmcmVzaF90b2tlbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFZlcmlmeUVycm9yKEFwcENvbmZpZy5PQVVUSF9DT05URVhUX0FQSV9FUlJPUiwgJ2FjY2Vzc190b2tlbiBleHBpcmVkIGFuZCByZWZyZXNoX3Rva2VuIG5vdCBmb3VuZCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG5ld1Rva2VuID0gYXdhaXQgdGhpcy5yZWZyZXNoVG9rZW4odG9rZW4pO1xuICAgICAgICAgICAgICAgIGxldCBvcmlnaW5hbFJlcXVlc3QgPSBhd2FpdCBhcGlSZXF1ZXN0KG9wdGlvbnMsIG5ld1Rva2VuLmFjY2Vzc190b2tlbik7XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IG9yaWdpbmFsUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IG5ld1Rva2VuXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAY2xhc3MgSW1wbGljaXRGbG93XG4gKi9cbmNsYXNzIEltcGxpY2l0RmxvdyBleHRlbmRzIEZsb3dBYnN0cmFjdCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuaXNWYWxpZENvbmZpZygpO1xuXG4gICAgICAgIHRoaXMuc3RvcmFnZUhhbmRsZXIgPSBuZXcgU3RvcmFnZUhhbmRsZXIoY29uZmlnLnN0b3JhZ2VUeXBlKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvbiBpc1ZhbGlkQ29uZmlnIFZhbGlkYXRlcyB0aGUgY29uZmlnIG9mIGFuIEltcGxpY2l0RmxvdyBpbnN0YW5jZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbmZpZyBpcyB2YWxpZFxuXHQgKiBUaHJvd3MgZXJyb3IgaWYgbm8gc3RvcmFnZVR5cGUgaW4gY29uZmlnIG9yIGluc3RhbnRpYXRpbmcgSW1wbGljaXRGbG93IGluIE5vZGVKU1xuXHQgKi9cbiAgICBpc1ZhbGlkQ29uZmlnKCkge1xuICAgICAgICBpZiAodXRpbHMuaXNOb2RlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkT0F1dGhDb25maWd1cmF0aW9uRXJyb3IoJ0ltcGxpY2l0IGZsb3cgaXMgbm90IHN1cHBvcnRlZCBpbiBOb2RlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5zdG9yYWdlVHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPQXV0aENvbmZpZ3VyYXRpb25FcnJvcignc3RvcmFnZVR5cGUgcHJvcGVydHkgaXMgcmVxdWlyZWQgaW4gY29uZmlnIHNldHRpbmdzIGZvciBJbXBsaWNpdCBmbG93Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEodGhpcy5jb25maWcucmVkaXJlY3RVcmkgJiYgdXRpbHMuaXNVcmwodGhpcy5jb25maWcucmVkaXJlY3RVcmkpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPQXV0aENvbmZpZ3VyYXRpb25FcnJvcignYSB2YWxpZCByZWRpcmVjdFVyaSBwcm9wZXJ0eSBpcyByZXF1aXJlZCBpbiBjb25maWcgc2V0dGluZ3MnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvbiByZWZyZXNoVG9rZW4gUmVmcmVzaGVzIHRoZSB0b2tlbiBpZiBpdCBoYXMgZXhwaXJlZFxuXHQgKiBAcGFyYW0ge29iamVjdH0gdG9rZW4gVGhlIHRva2VuIG9iamVjdCBjb250YWluaW5nIGFjY2Vzc190b2tlbiwgcmVmcmVzaF90b2tlbiAuLi5cblx0ICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFRocm93cyBOb3RBdmFpbGFibGVFcnJvcigpIGFzIHJlZnJlc2hfdG9rZW4gaXMgbm90IGF2YWlsYWJsZSBpbiBJbXBsaWNpdCBGbG93XG5cdCAqL1xuICAgIHJlZnJlc2hUb2tlbih0b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgTm90QXZhaWxhYmxlRXJyb3IoKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvbiBmZXRjaFRva2VuIFJldHJpZXZlcyB0aGUgdG9rZW4gb2JqZWN0IGZyb20gc3RvcmFnZVxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fHZvaWR9IFRva2VuIG9iamVjdCBmb3VuZCBpbiBzdG9yYWdlIG9yIHRocm93cyBlcnJvclxuXHQgKi9cbiAgICBmZXRjaFRva2VuKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy5zdG9yYWdlSGFuZGxlci5nZXRTdG9yYWdlKCd0b2tlbicpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uIHNldFNlc3Npb24gU2V0cyB0aGUgc2Vzc2lvbiBleHBpcmF0aW9uIGFjY29yZGluZyB0byB0aGUgZXhwaXJhdGlvbiBvZiB0aGUgc3RvcmVkIHRva2VuXG5cdCAqIFRoZSB0b2tlbiB3aWxsIGJlIGNsZWFyZWQgZnJvbSBzdG9yYWdlIG9uY2UgaXQgZXhwaXJlcyBhbmQgdGhlIHNlc3Npb24gd2lsbCBlbmQuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cbiAgICBfc2V0U2Vzc2lvbigpIHtcbiAgICAgICAgY29uc3QgZXhwaXJlc0F0ID0gSlNPTi5wYXJzZSh0aGlzLnN0b3JhZ2VIYW5kbGVyLmdldFN0b3JhZ2UoJ3Rva2VuJykpLmV4cGlyZXNfaW47XG4gICAgICAgIC8vIGNvbnN0IGNsb2NrU2tldyA9IEFwcENvbmZpZy5ERUZBVUxUX0NMT0NLX1NLRVc7XG4gICAgICAgIGNvbnN0IGNsb2NrU2tldyA9IDEwO1xuICAgICAgICBjb25zdCBkZWxheSA9IGV4cGlyZXNBdCAtIChEYXRlLm5vdygpIC0gY2xvY2tTa2V3KTtcblxuICAgICAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2VIYW5kbGVyLmNsZWFyU3RvcmFnZSgpO1xuICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb24gbG9naW4gQnVpbGRzIGEgbG9naW4gVVJMIHRvIGF1dGhvcml6ZSBhZ2FpbnN0IHVzaW5nIHRoZSBpbnN0YW5jZSdzIGNvbmZpZ1xuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBBdXRob3JpemF0aW9uIFVSTFxuXHQgKi9cbiAgICBsb2dpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1dGhvcml6ZSh0aGlzLmNvbmZpZyk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb24gbG9nb3V0IFJlZGlyZWN0cyB1c2VyIGFmdGVyIGFjY2Vzc1Rva2VuIGhhcyBleHBpcmVkLlxuXHQgKiBAcGFyYW1zIHtzdHJpbmd9IHBhdGggT3B0aW9uYWwgcGF0aCB0byByZWRpcmVjdCB0bywgZGVmYXVsdHMgdG8gaW5kZXggcGFnZS5cblx0ICovXG4gICAgYXN5bmMgbG9nb3V0KHBhdGgpIHtcbiAgICAgICAgbGV0IGFjY2Vzc1Rva2VuID0gdGhpcy5mZXRjaFRva2VuKCk7XG4gICAgICAgIGF3YWl0IHRoaXMucmV2b2tlVG9rZW4oYWNjZXNzVG9rZW4sICdhY2Nlc3NfdG9rZW4nKTtcbiAgICAgICAgYXdhaXQgdGhpcy5zdG9yYWdlSGFuZGxlci5jbGVhclN0b3JhZ2UoKTtcbiAgICAgICAgYXdhaXQgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UocGF0aCB8fCAnLycpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uIGhhbmRsZUNhbGxiYWNrIFN0b3JlcyB0b2tlbiBpbnRvIHNlc3Npb25TdG9yYWdlXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBQcm9taXNlIHJlamVjdGlvbiBpZiBlcnJvclxuXHQgKi9cbiAgICBoYW5kbGVDYWxsYmFjaygpIHtcbiAgICAgICAgbGV0IHVybE9iajtcbiAgICAgICAgY29uc3QgZXJyb3JDaGVjayA9IFJlZ0V4cCgnI2Vycm9yJyk7XG4gICAgICAgIGNvbnN0IGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcblxuICAgICAgICB1cmxPYmogPSB0eXBlb2YgaGFzaCA9PT0gJ29iamVjdCcgPyBoYXNoIDogdGhpcy5fcGFyc2VVcmxIYXNoKGhhc2gpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAoZXJyb3JDaGVjay50ZXN0KGhhc2gpKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHVybE9iaik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZUhhbmRsZXIuc2V0U3RvcmFnZSh1cmxPYmopO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdXJsXG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGNsYXNzIEF1dGhvcml6YXRpb25Db2RlRmxvd1xuICovXG5jbGFzcyBBdXRob3JpemF0aW9uQ29kZUZsb3cgZXh0ZW5kcyBGbG93QWJzdHJhY3Qge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICB0aGlzLmlzVmFsaWRDb25maWcoKTtcbiAgICAgICAgdGhpcy5jb25maWcuZ3JhbnRUeXBlID0gJ2F1dGhvcml6YXRpb25fY29kZSdcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvbiBpc1ZhbGlkQ29uZmlnIFZhbGlkYXRlcyB0aGUgY29uZmlnIG9mIGFuIEF1dGhvcml6YXRpb25Db2RlRmxvdyBpbnN0YW5jZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbmZpZyBpcyB2YWxpZFxuXHQgKiBUaHJvd3MgZXJyb3IgaWYgbm8gY2xpZW50U2VjcmV0IGluIGNvbmZpZ1xuXHQgKi9cbiAgICBpc1ZhbGlkQ29uZmlnKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmNsaWVudFNlY3JldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPQXV0aENvbmZpZ3VyYXRpb25FcnJvcignY2xpZW50U2VjcmV0IHByb3BlcnR5IGlzIHJlcXVpcmVkIGluIGNvbmZpZyBzZXR0aW5ncyBmb3IgQXV0aG9yaXphdGlvbiBDb2RlIGZsb3cnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISh0aGlzLmNvbmZpZy5yZWRpcmVjdFVyaSAmJiB1dGlscy5pc1VybCh0aGlzLmNvbmZpZy5yZWRpcmVjdFVyaSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE9BdXRoQ29uZmlndXJhdGlvbkVycm9yKCdhIHZhbGlkIHJlZGlyZWN0VXJpIHByb3BlcnR5IGlzIHJlcXVpcmVkIGluIGNvbmZpZyBzZXR0aW5ncycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jb25maWcucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE9BdXRoQ29uZmlndXJhdGlvbkVycm9yKCdyZXNwb25zZVR5cGUgcHJvcGVydHkgaXMgcmVxdWlyZWQgaW4gY29uZmlnIHNldHRpbmdzJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBnZXRUb2tlbihwYXJhbXMpIHtcblxuICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFZlcmlmeUVycm9yKEFwcENvbmZpZy5PQVVUSF9DT05URVhUX0NPTkZJR19TRVRUSU5HU19FUlJPUiwgJ2dldFRva2VuKHBhcmFtcyksIFBhcmFtcyBhcmUgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJyAmJiBwYXJhbXMuaW5jbHVkZXMoJz8nKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBWZXJpZnlFcnJvcihBcHBDb25maWcuT0FVVEhfQ09OVEVYVF9BUElfRVJST1IsICdnZXRUb2tlbihwYXJhbXMpLCBQYXJhbXMgbXVzdCBjb250YWluIGRhdGEgb2JqZWN0IG9yIHF1ZXJ5IHN0cmluZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHF1ZXJ5ID0gcGFyYW1zLnN1YnN0cmluZyhwYXJhbXMuaW5kZXhPZignPycpKTtcbiAgICAgICAgbGV0IGRhdGEgPSB0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnID8gcXVlcnkgOiBxcy5wYXJzZShxdWVyeSk7XG4gICAgICAgIGxldCBwYXRoID0gYCR7dGhpcy5jb25maWcudGVuYW50VXJsfS92MS4wL2VuZHBvaW50L2RlZmF1bHQvdG9rZW5gO1xuXG5cbiAgICAgICAgZGF0YS5yZWRpcmVjdF91cmkgPSB0aGlzLmNvbmZpZy5yZWRpcmVjdFVyaTtcbiAgICAgICAgZGF0YS5ncmFudF90eXBlID0gdGhpcy5jb25maWcuZ3JhbnRUeXBlO1xuICAgICAgICBkYXRhLmNsaWVudF9pZCA9IHRoaXMuY29uZmlnLmNsaWVudElkO1xuICAgICAgICBkYXRhLmNsaWVudF9zZWNyZXQgPSB0aGlzLmNvbmZpZy5jbGllbnRTZWNyZXQ7XG4gICAgICAgIGRhdGEuc2NvcGUgPSB0aGlzLmNvbmZpZy5zY29wZTtcblxuICAgICAgICBsZXQgZW5jb2RlZERhdGEgPSBxcy5zdHJpbmdpZnkoZGF0YSk7XG5cbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIHVybDogcGF0aCxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgIGRhdGE6IGVuY29kZWREYXRhXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGFwaVJlcXVlc3Qob3B0aW9ucyk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb24gYXV0aGVudGljYXRlIFJldHVybnMgYSBVUkwgdXNlZCB0byBhdXRoZW50aWNhdGUgYWdhaW5zdCB1c2luZyB0aGUgaW5zdGFuY2UncyBjb25maWdcblx0ICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gQXV0aGVudGljYXRpb24gVVJMXG5cdCAqL1xuICAgIGF1dGhlbnRpY2F0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuX2F1dGhvcml6ZSh0aGlzLmNvbmZpZykpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb24gcmVmcmVzaFRva2VuIFJlZnJlc2hlcyBhIHRva2VuIGlmIGl0IGhhcyBleHBpcmVkXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0b2tlbiBUaGUgdG9rZW4gb2JqZWN0IHRvIGJlIHJlZnJlc2hlZCBjb250YWluaW5nIGFjY2Vzc190b2tlbiwgcmVmcmVzaF90b2tlbiAuLi5cblx0ICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0fHZvaWQ+fSBSZXNwb25zZSBvYmplY3QgZnJvbSByZWZyZXNoaW5nIHRoZSB0b2tlblxuXHQgKi9cbiAgICByZWZyZXNoVG9rZW4odG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJlZnJlc2hUb2tlbih0b2tlbik7XG4gICAgfVxufVxuXG4vKipcbiAqIEBjbGFzcyBEZXZpY2VGbG93XG4gKi9cbmNsYXNzIERldmljZUZsb3cgZXh0ZW5kcyBGbG93QWJzdHJhY3Qge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICB0aGlzLmlzVmFsaWRDb25maWcoKTtcbiAgICAgICAgdGhpcy5QT0xMSU5HX1RJTUUgPSA1MDAwO1xuICAgICAgICB0aGlzLmNvbmZpZy5ncmFudFR5cGUgPSAndXJuOmlldGY6cGFyYW1zOm9hdXRoOmdyYW50LXR5cGU6ZGV2aWNlX2NvZGUnO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uIGlzVmFsaWRDb25maWcgVmFsaWRhdGVzIHRoZSBjb25maWcgb2YgYW4gRGV2aWNlRmxvdyBpbnN0YW5jZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbmZpZyBpcyB2YWxpZFxuXHQgKi9cbiAgICBpc1ZhbGlkQ29uZmlnKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmNsaWVudFNlY3JldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPQXV0aENvbmZpZ3VyYXRpb25FcnJvcignY2xpZW50U2VjcmV0IHByb3BlcnR5IGlzIHJlcXVpcmVkIGluIGNvbmZpZyBzZXR0aW5ncyBmb3IgIENvZGUgZmxvdycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uIGF1dGhvcml6ZSB1c2VkIHRvIGluaXRpYXRlIHJlcXVlc3QgYXQgL2RldmljZV9hdXRob3JpemUgRVAgd2l0aFxuXHQgKiBjbGllbnQgaWQgKGFuZCBzY29wZSBpZiBwcm92aWRlZClcblx0ICogQHJldHVybnMgVGhlIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgcmV0dXJuZWQgaW5jbHVkZXMgYSBkZXZpY2VfY29kZSwgdXNlcl9jb2RlIGFuZCB2ZXJpZmljYXRpb25fdXJpLlxuXHQgKiBOb3RlOiBkZXZpY2VfY29kZSBzaG91bGQgbm90IGJlIGV4cG9zZWQgdG8gdGhlIHVzZXIgYWdlbnQuXG5cdCAqL1xuICAgIGF1dGhvcml6ZSgpIHtcbiAgICAgICAgbGV0IGF1dGhTZXJ2ZXJQYXRoID0gYCR7dGhpcy5jb25maWcudGVuYW50VXJsfS9vaWRjL2VuZHBvaW50L2RlZmF1bHQvZGV2aWNlX2F1dGhvcml6YXRpb25gO1xuICAgICAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgICAgIGNsaWVudF9pZDogdGhpcy5jb25maWcuY2xpZW50SWQsXG4gICAgICAgICAgICBzY29wZTogdGhpcy5jb25maWcuc2NvcGVcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgZW5jb2RlZERhdGEgPSBxcy5zdHJpbmdpZnkoZGF0YSk7XG5cbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIHVybDogYXV0aFNlcnZlclBhdGgsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICBkYXRhOiBlbmNvZGVkRGF0YVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBhcGlSZXF1ZXN0KG9wdGlvbnMpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uIHBvbGxUb2tlbkFwaSBQb2xsaW5nIHRoZSB0b2tlbiBlbmRwb2ludCBvZiB0aGUgYXV0aG9yaXphdGlvbiBzZXJ2ZXJcblx0ICogQHBhcmFtIHtkZXZpY2VDb2RlfSBzdHJpbmcgdXNlZCBmb3IgcG9sbGluZyB0aGUgdG9rZW4gRVBcblx0ICogQHBhcmFtIHtkdXJhdGlvbn0gbnVtYmVyIE9wdGlvbmFsLCB1c2VkIHRvIHNldCB0aGUgcG9sbGluZyB0aW1lIGluIG1pbGxpc2Vjb25kcy4gRGVmYXVsdCA1MDAwIG1pbGxpc2Vjb25kcy5cblx0ICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gUmVzb2x2ZWQgb3IgUmVqZWN0ZWQgcHJvbWlzZS5cblx0ICovXG4gICAgYXN5bmMgcG9sbFRva2VuQXBpKGRldmljZUNvZGUsIGR1cmF0aW9uID0gdGhpcy5QT0xMSU5HX1RJTUUpIHtcbiAgICAgICAgaWYgKGR1cmF0aW9uIDwgdGhpcy5QT0xMSU5HX1RJTUUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRGV2ZWxvcGVyRXJyb3IoJ1RoZSBkZXZpY2UgbWFkZSBhbiBhdHRlbXB0IHdpdGhpbiBbNV0gc2Vjb25kcy4gVGhpcyByZXF1ZXN0IHdpbGwgbm90IGJlIHByb2Nlc3NlZC4nKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRldmljZUNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRGV2ZWxvcGVyRXJyb3IoJ05vIGRldmljZSBjb2RlIHZhbHVlIHByb3ZpZGVkLicpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXRoID0gYCR7dGhpcy5jb25maWcudGVuYW50VXJsfS92MS4wL2VuZHBvaW50L2RlZmF1bHQvdG9rZW5gO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBkYXRhID0ge1xuICAgICAgICAgICAgY2xpZW50X2lkOiB0aGlzLmNvbmZpZy5jbGllbnRJZCxcbiAgICAgICAgICAgIGNsaWVudF9zZWNyZXQ6IHRoaXMuY29uZmlnLmNsaWVudFNlY3JldCxcbiAgICAgICAgICAgIGdyYW50X3R5cGU6IHRoaXMuY29uZmlnLmdyYW50VHlwZSxcbiAgICAgICAgICAgIGRldmljZV9jb2RlOiBkZXZpY2VDb2RlXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IGVycm9yID0ge1xuICAgICAgICAgICAgbWVzc2FnZUlkOiAnJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHdoaWxlIChlcnJvci5tZXNzYWdlSWQgIT09ICdleHBpcmVkX3Rva2VuJyAmJiAhcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldFRva2VuKHsgZGF0YSwgcGF0aCB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB1dGlscy5zbGVlcChkdXJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IubWVzc2FnZURlc2NyaXB0aW9uKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvbiByZWZyZXNoVG9rZW4gUmVmcmVzaGVzIGEgdG9rZW4gaWYgaXQgaGFzIGV4cGlyZWRcblx0ICogQHBhcmFtIHtvYmplY3R9IHRva2VuIFRoZSB0b2tlbiBvYmplY3QgdG8gYmUgcmVmcmVzaGVkIGNvbnRhaW5pbmcgYWNjZXNzX3Rva2VuLCByZWZyZXNoX3Rva2VuIC4uLlxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3R8dm9pZD59IFJlc3BvbnNlIG9iamVjdCBmcm9tIHJlZnJlc2hpbmcgdGhlIHRva2VuXG5cdCAqL1xuICAgIHJlZnJlc2hUb2tlbih0b2tlbikge1xuICAgICAgICByZXR1cm4gc3VwZXIucmVmcmVzaFRva2VuKHRva2VuKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGNsYXNzIFJPUENGbG93XG4gKi9cbmNsYXNzIFJPUENGbG93IGV4dGVuZHMgRmxvd0Fic3RyYWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICAgICAgdGhpcy5pc1ZhbGlkQ29uZmlnKCk7XG4gICAgICAgIHRoaXMuY29uZmlnLmdyYW50VHlwZSA9ICdwYXNzd29yZCdcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvbiBpc1ZhbGlkQ29uZmlnIFZhbGlkYXRlcyB0aGUgY29uZmlnIG9mIGEgRGV2aWNlRmxvdyBpbnN0YW5jZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbmZpZyBpcyB2YWxpZFxuXHQgKi9cbiAgICBpc1ZhbGlkQ29uZmlnKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvbiBsb2dpbiBSZXRyaWV2ZXMgYSB0b2tlbiB1c2luZyB0aGUgc3VwcGxpZWQgY3JlZGVudGlhbHNcblx0ICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lIFRoZSB1c2VyJ3MgaWRlbnRpZmllclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHVzZXIncyBwYXNzd29yZFxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBSZXNwb25zZSBvYmplY3QgZnJvbSBsb2dpbiBjb250YWluaW5nIHRva2VuXG5cdCAqL1xuICAgIGxvZ2luKHVzZXJuYW1lLCBwYXNzd29yZCkge1xuICAgICAgICBpZiAoIXVzZXJuYW1lIHx8ICFwYXNzd29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBEZXZlbG9wZXJFcnJvcigndXNlcm5hbWUgYW5kIHBhc3N3b3JkIHBhcmFtcyBhcmUgcmVxdWlyZWQnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGF0aCA9IGAke3RoaXMuY29uZmlnLnRlbmFudFVybH0vdjEuMC9lbmRwb2ludC9kZWZhdWx0L3Rva2VuYDtcblxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgY2xpZW50X2lkOiB0aGlzLmNvbmZpZy5jbGllbnRJZCxcbiAgICAgICAgICAgIGNsaWVudF9zZWNyZXQ6IHRoaXMuY29uZmlnLmNsaWVudFNlY3JldCxcbiAgICAgICAgICAgIHVzZXJuYW1lOiB1c2VybmFtZSxcbiAgICAgICAgICAgIHBhc3N3b3JkOiBwYXNzd29yZCxcbiAgICAgICAgICAgIGdyYW50X3R5cGU6IHRoaXMuY29uZmlnLmdyYW50VHlwZSxcbiAgICAgICAgICAgIHNjb3BlOiB0aGlzLmNvbmZpZy5zY29wZVxuICAgICAgICB9O1xuXG4gICAgICAgIGxldCBlbmNvZGVkRGF0YSA9IHFzLnN0cmluZ2lmeShkYXRhKTtcblxuICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgdXJsOiBwYXRoLFxuICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgZGF0YTogZW5jb2RlZERhdGFcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYXBpUmVxdWVzdChvcHRpb25zKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvbiByZWZyZXNoVG9rZW4gUmVmcmVzaGVzIGEgdG9rZW4gaWYgaXQgaGFzIGV4cGlyZWRcblx0ICogQHBhcmFtIHtvYmplY3R9IHRva2VuIFRoZSB0b2tlbiBvYmplY3QgdG8gYmUgcmVmcmVzaGVkIGNvbnRhaW5pbmcgYWNjZXNzX3Rva2VuLCByZWZyZXNoX3Rva2VuIC4uLlxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3R8dm9pZD59IFJlc3BvbnNlIG9iamVjdCBmcm9tIHJlZnJlc2hpbmcgdGhlIHRva2VuXG5cdCAqL1xuICAgIHJlZnJlc2hUb2tlbih0b2tlbikge1xuICAgICAgICByZXR1cm4gc3VwZXIucmVmcmVzaFRva2VuKHRva2VuKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE9BdXRoQ29udGV4dDsiXX0=